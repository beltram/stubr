<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>stubr</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="getting-started/index.html"><strong aria-hidden="true">2.</strong> Getting started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/unit-test.html"><strong aria-hidden="true">2.1.</strong> unit test</a></li><li class="chapter-item expanded "><a href="getting-started/standalone.html"><strong aria-hidden="true">2.2.</strong> standalone</a></li></ol></li><li class="chapter-item expanded "><a href="contract/index.html"><strong aria-hidden="true">3.</strong> Contract Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contract/producer.html"><strong aria-hidden="true">3.1.</strong> As a producer</a></li><li class="chapter-item expanded "><a href="contract/consumer.html"><strong aria-hidden="true">3.2.</strong> As a consumer</a></li></ol></li><li class="chapter-item expanded "><a href="stubs/index.html"><strong aria-hidden="true">4.</strong> Writing Stubs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="stubs/request.html"><strong aria-hidden="true">4.1.</strong> Request</a></li><li class="chapter-item expanded "><a href="stubs/response.html"><strong aria-hidden="true">4.2.</strong> Response</a></li></ol></li><li class="chapter-item expanded "><a href="recording/index.html"><strong aria-hidden="true">5.</strong> Recording</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="recording/actix.html"><strong aria-hidden="true">5.1.</strong> Actix</a></li><li class="chapter-item expanded "><a href="recording/cli.html"><strong aria-hidden="true">5.2.</strong> Cli</a></li><li class="chapter-item expanded "><a href="recording/isahc.html"><strong aria-hidden="true">5.3.</strong> isahc</a></li><li class="chapter-item expanded "><a href="recording/reqwest.html"><strong aria-hidden="true">5.4.</strong> reqwest</a></li><li class="chapter-item expanded "><a href="recording/standalone.html"><strong aria-hidden="true">5.5.</strong> standalone</a></li></ol></li><li class="chapter-item expanded "><a href="cli.html"><strong aria-hidden="true">6.</strong> Cli</a></li><li class="chapter-item expanded "><a href="docker.html"><strong aria-hidden="true">7.</strong> Docker</a></li><li class="chapter-item expanded "><a href="benchmark.html"><strong aria-hidden="true">8.</strong> Benchmark</a></li><li class="chapter-item expanded "><a href="ide-completion.html"><strong aria-hidden="true">9.</strong> IDE completion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">stubr</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="stubr"><a class="header" href="#stubr">Stubr</a></h1>
<p>Stubr is a stubbing and contract testing tool. It supports the same API for writing stubs
as <a href="https://github.com/tomakehurst/wiremock">Wiremock</a>.
You can also see it as an adaptation of <a href="https://github.com/LukeMathWalker/wiremock-rs">wiremock-rs</a> with the ability to
write stubs as json files instead of code.</p>
<p>You might ask <strong>why would I want to do such a thing ?</strong> After all, code is a great way to write stubs. That's true ! But
it also comes with some limitations: <strong>it is hard to share.</strong> And it especially starts tickling your attention when you
try to do <a href="https://martinfowler.com/bliki/ContractTest.html">contract testing</a>. You have to share a <code>contract</code> between a
producer and a consumer. Sometimes, both are written in different languages, or with different frameworks ; and even
when that's not the case, they might both be sharing a different version of that wicked dependency which clash together.
Having your contract written in json has the benefits of being <strong>portable</strong>, <strong>lightweight</strong> and <strong>polyglot</strong> (if you
stick to a
standard API such as Wiremock's one). So you could for example test a producer service written in Java and vice versa !</p>
<p>Stubr aims at bridging multiple languages and framework and enable developers to test their integration with remote
application without having to mock their own code. It also enables them to shorten their feedback loop: no need for a
complex CI to make sure 2 application share the same API definition, everything can be done offline.</p>
<p>Then, beyond <a href="contract/index.html">contract testing</a>, it tries to cover others areas:</p>
<ul>
<li><a href="gs-unit-test.html">stubbing</a> in your Rust project for simulating remote services your app depends on</li>
<li><a href="recording/index.html">recording</a> for capturing http traffic and turning it into a stub file</li>
<li>standalone for running stubr stub server from anywhere and benefiting from Rust performances. Available as
a <a href="cli.html">cli</a> or a <a href="docker.html">Docker image</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>You will of course want to use stubr in your Rust project. We will cover here the case where you want to mock an external
http application you do not own (if you own it, you might be interested in <a href="getting-started/../contract/index.html">contract testing</a>).</p>
<p><strong>First you need a stub.</strong> A stub is a json file which represents the endpoint you want to mock. You have 2 options from
now on:</p>
<ul>
<li><a href="getting-started/../recording/index.html">Record</a> the existing application (if you are lazy)</li>
<li><a href="getting-started/../stubs/index.html">Write the json stub yourself</a> ü•µ</li>
</ul>
<p>We are going to be even lazier and simply create the json stub with a command.</p>
<p>You should have a project layout like this:</p>
<pre><code class="language-text">‚îú‚îÄ‚îÄ src
‚îÇ   ‚îú‚îÄ‚îÄ lib.rs
‚îî‚îÄ‚îÄ tests
    ‚îú‚îÄ‚îÄ stubs
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ README.md
</code></pre>
<p>We are going to create the stub under <code>tests/stubs/</code>, the default location. You can place them wherever you want of course,
but you'll see it's more convenient to place them here.</p>
<pre><code class="language-bash">echo &quot;{\&quot;request\&quot;: {\&quot;method\&quot;: \&quot;GET\&quot;, \&quot;urlPath\&quot;: \&quot;/hello\&quot;}, \&quot;response\&quot;: { \&quot;body\&quot;: \&quot;Hello stubr\&quot; }}&quot; &gt; tests/stubs/hello.json
</code></pre>
<p>And with a few lines of code we can spawn a mock server and call (here with reqwest for example).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use asserhttp::*;

#[tokio::test]
async fn getting_started() {
    // run a mock server with the stub üëá
    let stubr = stubr::Stubr::start(&quot;tests/stubs/hello.json&quot;).await;
    // or use 'start_blocking' for a non-async version

    // the mock server started on a random port e.g. '127.0.0.1:43125'
    // so we use the stub instance 'path' (or 'uri') method to get the address back
    let uri = stubr.path(&quot;/hello&quot;);
    reqwest::get(uri).await
        // (optional) use asserhttp for assertions
        .expect_status_ok()
        .expect_content_type_text()
        .expect_body_text_eq(&quot;Hello stubr&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>But we can further shorten this with a attribute macro: <code>#[stubr::mock]</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use asserhttp::*;

#[tokio::test]
#[stubr::mock(&quot;hello.json&quot;)] // üëà this starts the mock server
async fn getting_started() {
    // a local binding 'stubr' has been created, equivalent to the one before
    let uri = stubr.path(&quot;/hello&quot;);
    reqwest::get(uri).await
        .expect_status_ok()
        .expect_content_type_text()
        .expect_body_text_eq(&quot;Hello stubr&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>You can also use the macro in non-async test methods of course, the macro will adapt by itself.<br />
Note that here you can omit the <code>tests/stubs/</code> path prefix. If you placed your files in the default location, they are
going to be searched from there.<br />
As well, you can mount many stubs with the macro e.g. <code>#[stubr::mock(&quot;hello.json&quot;, &quot;goodbye.json&quot;)]</code>.
By default, if you take care to place only stubs with different request matching under <code>tests/stubs</code>, you can simply
place <code>#[stubr::mock]</code>. It will recursively mount all the stubs under <code>tests/stubs</code>, searching also in subdirectories.</p>
<p>Here are all the options you can use with the attribute macro</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
#[stubr::mock(full_path = &quot;tests/book/hello.json&quot;, port = 1234, verify = true)]
async fn getting_started() {}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>full_path</code>: use this if your stubs are not under <code>tests/stubs</code> but elsewhere. Note that it can point to a directory.</li>
<li><code>port</code> when you want an explicit port for your mock server</li>
<li><code>verify</code> to turn on verification of the number of times a stub gets called (<code>expect</code> field in your stubs). 
See <a href="getting-started/../stubs/response.html#simulate-fault">simulating fault</a> for reference</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-1"><a class="header" href="#getting-started-1">Getting started</a></h1>
<p>You can use stubr as a standalone mock server i.e. an executable. To learn more read the pages about how to use the
<a href="getting-started/../cli.html">cli</a> or <a href="getting-started/../docker.html">as a Docker image</a>.</p>
<p>For this short demo we are going to use the cli. We will create a http stub, mount it on a stub server and then call it
to verify it works.</p>
<h2 id="installation"><a class="header" href="#installation">installation</a></h2>
<h4 id="recommended"><a class="header" href="#recommended">recommended</a></h4>
<p><em>If you don't have it, install rustup from <a href="https://rustup.rs/">here</a>.</em></p>
<pre><code class="language-bash">cargo install stubr-cli
</code></pre>
<h4 id="or-from-precompiled-binaries"><a class="header" href="#or-from-precompiled-binaries">or from precompiled binaries</a></h4>
<p>Those binaries are stripped with <a href="https://upx.github.io/">upx</a> and then compressed. They are likely to be smaller than
the ones built by rustc which might be preferable in certain conditions</p>
<h6 id="macos"><a class="header" href="#macos">macos</a></h6>
<pre><code class="language-bash">curl -L https://github.com/beltram/stubr/releases/latest/download/stubr-macos.tar.gz | tar xz - -C /usr/local/bin
</code></pre>
<h6 id="linux"><a class="header" href="#linux">linux</a></h6>
<pre><code class="language-bash">curl -L https://github.com/beltram/stubr/releases/latest/download/stubr-linux.tar.gz | tar xz - -C /usr/local/bin
</code></pre>
<h6 id="windows"><a class="header" href="#windows">windows</a></h6>
<p>Install binary from <a href="https://github.com/beltram/stubr/releases/latest/download/stubr-windozs.zip">here</a>.</p>
<h2 id="hello-world-"><a class="header" href="#hello-world-">Hello world !</a></h2>
<p>We are going to create the simplest stub possible. It will accept any http method on any path and will respond <code>200 OK</code>.</p>
<pre><code class="language-bash">cat &gt; stub.json &lt;&lt;- EOF
{
  &quot;request&quot;: {
    &quot;method&quot;: &quot;ANY&quot;
  },
  &quot;response&quot;: {
    &quot;status&quot;: 200,
    &quot;body&quot;: &quot;Hello world !&quot;,
  }
}
EOF
</code></pre>
<p>A few things about a stub:</p>
<ul>
<li>It is a json file. First because it is the format supported by <a href="https://github.com/tomakehurst/wiremock">Wiremock</a> and
we want to be compatible with it. Also, most of the time, your http APIs will consume/produce json data in their
bodies. So you can inline the request/response body in this file without externalizing it.</li>
<li><code>request { .. }</code> is where we define <strong>request matching</strong> i.e. &quot;<em>conditions the incoming http request has to satisfy in
order for the response part to be served</em>&quot;</li>
<li><code>response { .. }</code> is the part where you define what the stub server will respond if all request matchings pass.</li>
</ul>
<h4 id="mount-it"><a class="header" href="#mount-it">mount it</a></h4>
<p>The cli can spawn a http server with a path to the file or folder containing json stubs. By default, it will try to bind
to a random port, here we force it to attach to port <code>8080</code>.</p>
<pre><code class="language-bash">stubr stub.json -p 8080 &amp;
</code></pre>
<h4 id="call-it"><a class="header" href="#call-it">call it</a></h4>
<p>Now let's verify our stub server is up and running and that it serves our stubs the right way.</p>
<pre><code class="language-bash">curl -i http://localhost:8080
</code></pre>
<p>Which should output:</p>
<pre><code class="language-bash">HTTP/1.1 200 OK
server: stubr(0.4.14)
content-length: 0
date: Fri, 22 Jul 2022 19:31:48 GMT

Hello world !%
</code></pre>
<p>or with httpie</p>
<pre><code class="language-bash">http :8080
</code></pre>
<h2 id="hello-name-"><a class="header" href="#hello-name-">Hello {name} !</a></h2>
<p>Now let's spice things a bit and make our stub a bit more dynamic by capturing a part of the request path and template
it in the response (this is called <a href="getting-started/../stubs/response.html">response templating</a>).</p>
<p>But first let's kill the previous server</p>
<pre><code class="language-bash">lsof -ti tcp:8080 | xargs kill
</code></pre>
<pre><code class="language-bash">cat &gt; hello.json &lt;&lt;- EOF
{
  &quot;request&quot;: {
    &quot;method&quot;: &quot;GET&quot;,
    &quot;urlPathPattern&quot;: &quot;/hello/(.+)&quot;
  },
  &quot;response&quot;: {
    &quot;status&quot;: 200,
    &quot;body&quot;: &quot;Hello {{request.pathSegments.[1]}} !&quot;,
    &quot;transformers&quot;: [&quot;response-template&quot;]
  }
}
EOF
</code></pre>
<p>Here:</p>
<ul>
<li><code>&quot;urlPathPattern&quot;: &quot;/hello/(.+)&quot;</code> is one way to express URL matching. It contains a regular hardcoded path <code>/hello/</code>
and a regular expression <code>(.+)</code> which has to match in order for the stub response to be served.</li>
<li><code>&quot;transformers&quot;: [&quot;response-template&quot;]</code> will activate response templating. This allows you to inject a part of the
request in the response. Prefer using it over hardcoded values when your real life application actually does that. The
more you use it the better your test accuracy will be.</li>
<li><code>{{request.pathSegments.[1]}}</code> now that response templating is enabled, you can inject parts of your request in the
response. With <a href="https://github.com/tomakehurst/wiremock">Wiremock</a> as with stubr, we
use <a href="https://handlebarsjs.com/">handlebars</a> templates to do such a
thing. <a href="getting-started/../stubs/response.html">Many response templates are available</a> in stubr in order to pick whatever part
of the request you want.</li>
</ul>
<h4 id="mount-it-1"><a class="header" href="#mount-it-1">Mount it</a></h4>
<pre><code class="language-bash">stubr hello.json -p 8080 &amp;
</code></pre>
<h4 id="call-it-1"><a class="header" href="#call-it-1">call it</a></h4>
<pre><code class="language-bash">curl -i http://localhost:8080/hello/stubr
</code></pre>
<p>Which should output:</p>
<pre><code class="language-bash">HTTP/1.1 200 OK
server: stubr(0.4.14)
content-type: text/plain
content-length: 13
date: Sat, 23 Jul 2022 09:25:42 GMT

Hello stubr !%
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="as-a-producer"><a class="header" href="#as-a-producer">As a producer</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="as-a-consumer"><a class="header" href="#as-a-consumer">As a consumer</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stubs"><a class="header" href="#stubs">Stubs</a></h1>
<p>Writing stubs can be challenging and time-consuming. Stubr tries to assist by
providing <a href="stubs/../ide-completion.html">IDE completion</a> or by <a href="stubs/../recording/index.html">recording</a> live traffic into stubs. But
you still have to know how to write a stub and what helpers you have in order to <a href="stubs/relaxing.html">relax</a> your stubs as much
as possible.</p>
<p>You will find here in a single snippet <strong>ALL</strong> the fields/helpers available to you:</p>
<pre><code class="language-json">{
  &quot;id&quot;: &quot;82d86e05-9ee0-44ca-9a8d-1fc6f719437e&quot;, // (optional) unique stub identifier. Returned in 'Matched-Stub-Id' header
  &quot;priority&quot;: 1, // (optional) helps solving interlaced conditions (many stubs match the request). 1 is the highest priority, 255 the lowest
  &quot;request&quot;: {
    &quot;method&quot;: &quot;GET&quot;, // (optional) http method. Can be &quot;ANY&quot; to match any method. Defaults to &quot;ANY&quot;
    &quot;urlPath&quot;: &quot;/api/exact-uri&quot;, // exact URI match
    &quot;urlPathPattern&quot;: &quot;/api/regex-uri/([a-z]{4})&quot;, // URI must match regex
    &quot;urlPattern&quot;: &quot;/api/regex-uri/([a-z]{4})\\?and=([a-z]{4})&quot;, // URI &amp; query must match regex
    &quot;url&quot;: &quot;/api/uri?age=young&quot;, // raw URI + query parameters by equality matching
    &quot;queryParameters&quot;: {
      &quot;firstname&quot;: { &quot;equalTo&quot;: &quot;beltram&quot; }, // by equality matching (can also be an int, or a boolean)
      &quot;lastname&quot;: { &quot;equalTo&quot;: &quot;maldant&quot;, &quot;caseInsensitive&quot;: true }, // case insensitve equality
      &quot;age&quot;: { &quot;absent&quot;: true }, // must be absent
      &quot;city&quot;: { &quot;contains&quot;: &quot;a&quot; }, // must contain the letter 'a'
      &quot;title&quot;: { &quot;matches&quot;: &quot;([A-Za-z]+)&quot; }, // must match regex
      &quot;job&quot;: { &quot;doesNotMatch&quot;: &quot;([A-Za-z]+)&quot; }, // or must not match regex
    },
    &quot;headers&quot;: {
      &quot;content-type&quot;: { &quot;equalTo&quot;: &quot;application/json&quot; } // by equality matching
      // .. then all matchers described above for query parameters are also applicable here
    },
    &quot;basicAuth&quot; : { // exact Basic authentication matching
      &quot;username&quot;: &quot;user&quot;,
      &quot;password&quot;: &quot;pass&quot;
    },
    &quot;jwtAuth&quot;: {
      &quot;equalTo&quot;: &quot;eyJhbGciOiJSUzI1NiJ9.e30.MBkQ...&quot;, // plain JWT token
      &quot;alg&quot;: {
        &quot;equalTo&quot;: &quot;RS256&quot;, // JWT algorithm by equality matcher
        &quot;oneOf&quot;: [&quot;RS256&quot;, &quot;HS256&quot;] // JWT must contain one of these algorithms
      },
      &quot;payloadPatterns&quot;: [
        // all matchers available in 'bodyPatterns' ‚¨áÔ∏è
      ]
    },
    &quot;bodyPatterns&quot;: [
      { &quot;equalToJson&quot;: {&quot;name&quot;: &quot;bob&quot;} }, // strict json request body equality
      { &quot;equalToJson&quot;: {&quot;name&quot;: &quot;bob&quot;}, &quot;ignoreExtraElements&quot;: true }, // ignore extra json fields supplied in request body. Default to false.
      { &quot;equalToJson&quot;: {&quot;name&quot;: &quot;bob&quot;}, &quot;ignoreArrayOrder&quot;: true }, // ignore array items order. Default to false.
      { &quot;matchesJsonPath&quot;: &quot;$.name&quot; }, // must just match json path
      { &quot;matchesJsonPath&quot;: &quot;$.consoles[?(@.name == 'xbox')]&quot; }, // must match json path + equality
      { &quot;matchesJsonPath&quot;: &quot;$.consoles[?(@.price &gt; 200)]&quot; }, // must match json path + bound
      { &quot;expression&quot;: &quot;$.name&quot;, &quot;contains&quot;: &quot;at&quot; }, // must match json path + contain the string 'at'
      { &quot;expression&quot;: &quot;$.user&quot;, &quot;equalToJson&quot;: { &quot;name&quot;: &quot;bob&quot; } }, // must match json path + be equal
      { &quot;binaryEqualTo&quot;: &quot;AQID&quot; /* Base 64 */ } // byte array equality
    ]
  },
  &quot;response&quot;: {
    &quot;status&quot;: 200, // (required) response status
    &quot;fixedDelayMilliseconds&quot;: 2000, // delays response by 2 seconds
    &quot;jsonBody&quot;: { // json response body (automatically adds 'content-type:application/json' header)
      &quot;name&quot;: &quot;john&quot;,
      &quot;surnames&quot;: [ &quot;jdoe&quot;, &quot;johnny&quot; ]
    },
    &quot;body&quot;: &quot;Hello World !&quot;, // text response (automatically adds 'Content-Type:text/plain' header)
    &quot;base64Body&quot;: &quot;AQID&quot;, // binary Base 64 body
    &quot;bodyFileName&quot;: &quot;tests/stubs/response.json&quot;, // path to a .json or .txt file containing the response
    &quot;headers&quot;: {
      &quot;content-type&quot;: &quot;application/pdf&quot; // returns this response header
    },
    // ..now response templating
    // it uses handlebars and allows you to define dynamic response based upon the content of the request
    // it can be used in &quot;jsonBody&quot;, &quot;body&quot;, &quot;bodyFileName&quot; or &quot;headers&quot;
    &quot;transformers&quot;: [&quot;response-template&quot;], // required to activate response templating
    &quot;jsonBody&quot;: {
      &quot;url-path-and-query&quot;: &quot;{{request.url}}&quot;,
      &quot;url-path&quot;: &quot;{{request.path}}&quot;,
      &quot;url-path-segments&quot;: &quot;{{request.pathSegments.[1]}}&quot;, // returns 'two' given '/one/two/three' path
      &quot;query&quot;: &quot;{{request.query.kind}}&quot;, // returns 'comics' given '/api/books?kind=comics'
      &quot;multi-query&quot;: &quot;{{request.query.kind.[1]}}&quot;, // returns 'novel' given '/api/books?kind=comics&amp;kind=novel'
      &quot;method&quot;: &quot;{{request.method}}&quot;, // http request method e.g. &quot;POST&quot;
      &quot;header&quot;: &quot;{{request.headers.Content-Type}}&quot;, // returns request header with given key
      &quot;multi-header&quot;: &quot;{{request.headers.cache-control.[0]}}&quot;, // returns first value of &quot;cache-control&quot; values
      &quot;body&quot;: &quot;{{request.body}}&quot;, // returns raw request body
      &quot;from-request&quot;: &quot;{{jsonPath request.body '$.name'}}&quot;, // takes field 'name' from json request body
      &quot;now&quot;: &quot;{{now}}&quot;, // current datetime (UTC)
      &quot;now-fmt&quot;: &quot;{{now format='yyyy/MM/dd'}}&quot;, // with custom Java SimpleDateFormat
      &quot;now-fmt-epoch&quot;: &quot;{{now format='epoch'}}&quot;, // epoch in milliseconds
      &quot;now-fmt-unix&quot;: &quot;{{now format='unix'}}&quot;, // epoch in seconds
      &quot;now-positive-offset&quot;: &quot;{{now offset='3 days'}}&quot;, // human time positive offset
      &quot;now-negative-offset&quot;: &quot;{{now offset='-3 days'}}&quot;, // human time negative offset
      &quot;now-with-timezone&quot;: &quot;{{now timezone='Europe/Rome'}}&quot;,
      &quot;number-is-odd&quot;: &quot;{{isOdd 3}}&quot;, // or 'isEven'
      &quot;string-capitalized&quot;: &quot;{{capitalize mister}}&quot;, // or 'decapitalize'
      &quot;string-uppercase&quot;: &quot;{{upper mister}}&quot;, // or 'lower'
      &quot;number-stripes&quot;: &quot;{{stripes request.body 'if-even' 'if-odd'}}&quot;,
      &quot;string-trim&quot;: &quot;{{trim request.body}}&quot;, // removes leading &amp; trailing whitespaces
      &quot;size&quot;: &quot;{{size request.body}}&quot;, // string length or array length
      &quot;base64-encode&quot;: &quot;{{base64 request.body padding=false}}&quot;, // padding is optional and defaults to true
      &quot;base64-decode&quot;: &quot;{{base64 request.body decode=true}}&quot;,
      &quot;url-encode&quot;: &quot;{{urlEncode request.header.x-raw}}&quot;,
      &quot;url-decode&quot;: &quot;{{urlEncode request.header.x-encoded decode=true}}&quot;,
      // you can also use 'any*' helpers. They will produce a random value
      &quot;regex&quot;: &quot;{{anyRegex '[a-z]{4}'}}&quot;, // generate a random string matching regex
      &quot;string&quot;: &quot;{{anyNonEmptyString}}&quot;, // or '{{anyNonEmptyString}}'
      &quot;alphanum&quot;: &quot;{{anyAlphaNumeric}}&quot;,
      &quot;boolean&quot;: &quot;{{anyBoolean}}&quot;,
      &quot;uuid&quot;: &quot;{{anyUuid}}&quot;,
      &quot;ip&quot;: &quot;{{anyIpAddress}}&quot;, // e.g. '127.0.0.1'
      &quot;host&quot;: &quot;{{anyHostname}}&quot;, // e.g. 'https://github.com'
      &quot;email&quot;: &quot;{{anyEmail}}&quot;, // e.g. 'john.doe@gmail.com'
      &quot;enum&quot;: &quot;{{anyOf 'alpha' 'beta' 'gamma'}}&quot;, // returns randomly one of those 3 values
      &quot;number&quot;: &quot;{{anyNumber}}&quot;, // integer or float 
      &quot;integer&quot;: &quot;{{anyI32}}&quot;, // also all Rust int types (u32, u8, i64 etc..)
      &quot;float&quot;: &quot;{{anyFloat}}&quot;,
      &quot;anyDate&quot;: &quot;{{anyDate}}&quot; // or 'anyTime', 'anyDatetime', 'anyIso8601'
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="request"><a class="header" href="#request">Request</a></h1>
<p>With request matching you have to describe all the conditions the incoming http requests have to match in order for your
stub response to be served. Most of the time, you will opt in for a conservative approach where you will have exhaustive
and strict conditions. That's when you want to assess the http caller behaves the right way. Other times you do not care
about request matching at all e.g. you use stubr to benchmark a reverse proxy: in that
case <code>request { &quot;method&quot;: &quot;ANY&quot; }</code> is enough. <strong>Just write the request matching you need</strong>.</p>
<h2 id="method"><a class="header" href="#method">Method</a></h2>
<p>Expects the request method. Use <code>ANY</code> when you do not care which method it will be.<br />
Available verbs are <code>GET</code>, <code>HEAD</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>CONNECT</code>, <code>OPTIONS</code>, <code>TRACE</code>, <code>PATCH</code></p>
<p><em>Note: <code>method</code> is optional and defaults to <code>ANY</code></em></p>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;method&quot;: &quot;GET&quot;
  }
}
</code></pre>
<h2 id="uri"><a class="header" href="#uri">URI</a></h2>
<p>To match request's URI (and maybe its query parameters). Only one of the following matcher is allowed. If more than one
are present, it does not fail but chooses one matcher according to the descending
priority <code>url</code> &gt; <code>urlPath</code> &gt; <code>urlPattern</code> &gt; <code>urlPathPattern</code></p>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;url&quot;: &quot;/api/uri?age=young&quot;,
    &quot;urlPath&quot;: &quot;/api/exact-uri&quot;,
    &quot;urlPattern&quot;: &quot;/api/regex-uri/([a-z]{4})\\?and=([a-z]{4})&quot;,
    &quot;urlPathPattern&quot;: &quot;/api/regex-uri/([a-z]{4})&quot;
  }
}
</code></pre>
<ul>
<li><code>url</code>: Matches by equality the URI and query parameters.</li>
<li><code>urlPath</code>: Matches by equality <strong>just</strong> the URI without query parameters.</li>
<li><code>urlPattern</code>: Matches URI and query parameters. Path segments and query parameters value can contain regexes.</li>
<li><code>urlPathPattern</code>: Matches <strong>just</strong> the URI without query parameters. Path segments can contain regexes.</li>
</ul>
<h2 id="query-parameters"><a class="header" href="#query-parameters">Query parameters</a></h2>
<p>Allows matching query parameters. Prefer this instead of <a href="stubs/request.html#uri">URI</a> matching just because it is clearer. Multivalued
query parameters are not supported yet.</p>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;queryParameters&quot;: {
      &quot;firstname&quot;: { &quot;equalTo&quot;: &quot;beltram&quot; },
      &quot;lastname&quot;: { &quot;equalTo&quot;: &quot;maldant&quot;, &quot;caseInsensitive&quot;: true },
      &quot;age&quot;: { &quot;absent&quot;: true },
      &quot;birthdate&quot;: { &quot;absent&quot;: false },
      &quot;city&quot;: { &quot;contains&quot;: &quot;at&quot; },
      &quot;title&quot;: { &quot;matches&quot;: &quot;([A-Za-z]+)&quot; },
      &quot;job&quot;: { &quot;doesNotMatch&quot;: &quot;([A-Za-z]+)&quot; }
    }
  }
}
</code></pre>
<ul>
<li><code>equalTo</code> by equality matcher. Can be a string, a boolean, a number, null etc... Can be turned case-insensitive
with <code>caseInsensitive</code>.</li>
<li><code>absent</code> specified query parameter key must be absent/present.</li>
<li><code>contains</code> value must contain the supplied string in a case-insensitive way</li>
<li><code>matches</code>/<code>doesNotMatch</code> value must match the supplied regex (or not)</li>
</ul>
<h2 id="headers"><a class="header" href="#headers">Headers</a></h2>
<p>Header matcher are <strong>exactly</strong> the same as <a href="stubs/request.html#query-parameters">query parameter matcher</a> above.</p>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;headers&quot;: {
      &quot;content-type&quot;: { &quot;equalTo&quot;: &quot;application/json&quot; }
    }
  }
}
</code></pre>
<h2 id="authorization"><a class="header" href="#authorization">Authorization</a></h2>
<p>Those matcher are exclusive to stubr and not available in Wiremock. They allow crafting more relaxed request matchers
when it comes to authorization. You could for example have stubs specialized for a specific user (we sometimes persona).</p>
<p>You can have matchers for Basic authentication (<a href="https://datatracker.ietf.org/doc/html/rfc7617">RFC 7617</a>). For example,
for matching <code>Authorization: Basic am9obi5kb2U6Y2hhbmdlbWU=</code> you would have:</p>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;basicAuth&quot;: {
      &quot;username&quot;: &quot;john.doe&quot;,
      &quot;password&quot;: &quot;changeme&quot;
    }
  }
}
</code></pre>
<p>You can also match a JWT token in the <code>Authorization</code> header as
per <a href="https://datatracker.ietf.org/doc/html/rfc7519">RFC 7519</a></p>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;jwtAuth&quot;: {
      &quot;equalTo&quot;: &quot;eyJhbGciOiJSUzI1NiJ9.e30.MBkQ...&quot;,
      &quot;alg&quot;: {
        &quot;equalTo&quot;: &quot;RS256&quot;,
        &quot;oneOf&quot;: [ &quot;RS256&quot;, &quot;HS256&quot; ]
      },
      &quot;payloadPatterns&quot;: [
        { &quot;equalToJson&quot;: { &quot;iss&quot;: &quot;john.doe&quot; } },
        { &quot;equalToJson&quot;: { &quot;exp&quot;: 1300819380 } },
        {
          &quot;expression&quot;: &quot;$.address&quot;,
          &quot;equalToJson&quot;: { &quot;street&quot;: &quot;rue de Rivoli&quot;, &quot;city&quot;: &quot;Paris&quot; }
        }
      ]
    }
  }
}
</code></pre>
<ul>
<li><code>equalTo</code> by equality matcher. Equivalent to <code>&quot;headers&quot;:{&quot;authorization&quot;:{&quot;equalTo&quot;: &quot;...&quot;}}</code>. If you have this
matcher, all the other ones will be ignored</li>
<li><code>alg.equalTo</code> by equality matcher. JWT algorithm has to be exactly this</li>
<li><code>alg.oneOf</code> JWT algorithm has to be one of the supplied values. Here are all the supported JWT
algorithms [<code>HS256</code>, <code>HS384</code>, <code>HS512</code>, <code>ES256</code>, <code>ES384</code>, <code>RS256</code>, <code>RS384</code>, <code>RS512</code>, <code>PS256</code>, <code>PS384</code>, <code>PS512</code>, <code>EdDSA</code>]</li>
<li><code>payloadPatterns</code> for matching the JWT body. Exactly the same matcher as <a href="stubs/request.html#body">body</a> ones.</li>
</ul>
<h2 id="body"><a class="header" href="#body">Body</a></h2>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;bodyPatterns&quot;: [
      { &quot;equalToJson&quot;: { &quot;name&quot;: &quot;bob&quot; } },
      {
        &quot;equalToJson&quot;: {&quot;names&quot;: [&quot;alice&quot;, &quot;bob&quot;]},
        &quot;ignoreExtraElements&quot;: true,
        &quot;ignoreArrayOrder&quot;: true
      },
      { &quot;matchesJsonPath&quot;: &quot;$.name&quot; },
      { &quot;matchesJsonPath&quot;: &quot;$.consoles[?(@.name == 'xbox')]&quot; },
      { &quot;matchesJsonPath&quot;: &quot;$.consoles[?(@.price &gt; 200)]&quot; },
      { &quot;expression&quot;: &quot;$.name&quot;, &quot;contains&quot;: &quot;at&quot; },
      { &quot;expression&quot;: &quot;$.user&quot;, &quot;equalToJson&quot;: { &quot;name&quot;: &quot;bob&quot; } },
      { &quot;expression&quot;: &quot;$.age&quot;, &quot;equalToJson&quot;: 42 },
      { &quot;binaryEqualTo&quot;: &quot;AQID&quot; }
    ]
  }
}
</code></pre>
<ul>
<li><code>equalToJson</code> strict equality matcher. Request body has to be exactly equal to this. If it is not used
with <code>expression</code>, all other matchers will be ignored. However, it can be relaxed with:
<ul>
<li><code>ignoreExtraElements</code> to ignore json fields in the http request not present in the matcher</li>
<li><code>ignoreArrayOrder</code> to match json arrays regardless the order of their items</li>
</ul>
</li>
<li><code>expression</code> a <a href="https://www.ietf.org/archive/id/draft-goessner-dispatch-jsonpath-00.html">JSONPath</a> matcher used to
narrow the matching. The matched expression has then to be verified by either:
<ul>
<li><code>equalToJson</code> for strict equality (can be another json object, a string, number etc..)</li>
<li><code>contains</code> ; if json matched by <code>expression</code> is a string it must contain the supplied string</li>
</ul>
</li>
<li><code>matchesJsonPath</code> json request body has to contain the supplied key identified by
a <a href="https://www.ietf.org/archive/id/draft-goessner-dispatch-jsonpath-00.html">JSONPath</a>. You can also
use <a href="https://docs.hevodata.com/sources/streaming/rest-api/writing-jsonpath-expressions/">JSONPath expression</a> to also
filter and match the json values</li>
<li><code>binaryEqualTo</code> byte equality matcher. Has to be base 64 encoded</li>
</ul>
<h2 id="priority"><a class="header" href="#priority">Priority</a></h2>
<p>Sometimes, you can have 2 different stubs that could both match a given http request. This happens most of the time when
you start writing stubs for your application errors. You basically should have:</p>
<ul>
<li>one relaxed stub for your nominal case matching for example <code>&quot;urlPathPattern&quot;: &quot;/users/([0-9]{4})&quot;</code></li>
<li>one stub for each error with hardcoded value e.g. <code>&quot;urlPath&quot;: &quot;/users/1234&quot;</code> for a <code>404</code> response</li>
</ul>
<p>The issue here is that if your stub server receives a <code>GET /users/1234</code> request, both stubs will match. You want your
error stub to have a higher than the nominal e.g. error stub will have a priority of 1 whereas the nominal one will have
a priority of 2.</p>
<pre><code class="language-json">{
  &quot;priority&quot;: 1
}
</code></pre>
<ul>
<li><code>priority</code> a u8. 1 is the highest priority, 255 the lowest, 5 the default value when absent. It is optional.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="response"><a class="header" href="#response">Response</a></h1>
<p>In the response part, you have to define the actual http response the stub server will serve when the stub matches the
incoming http request as we defined it with <a href="stubs/../stubs/request.html">request matching</a></p>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<p>The http response status. In the range <code>[100..599]</code>.</p>
<pre><code class="language-json">{
  &quot;response&quot;: {
    &quot;status&quot;: 200
  }
}
</code></pre>
<h2 id="header"><a class="header" href="#header">Header</a></h2>
<p>Http response headers. Note that keys are case-insensitive. Multivalued headers are not supported yet. You can
use <a href="stubs/response.html#response-templating">response templating</a> here as well if you add <code>&quot;transformers&quot;: [&quot;response-template&quot;]</code>.</p>
<pre><code class="language-json">{
  &quot;response&quot;: {
    &quot;transformers&quot;: [
      &quot;response-template&quot;
    ],
    &quot;headers&quot;: {
      &quot;content-type&quot;: &quot;application/json&quot;,
      &quot;ETag&quot;: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;,
      &quot;location&quot;: &quot;{{request.url}}/1234&quot;
    }
  }
}
</code></pre>
<h2 id="body-1"><a class="header" href="#body-1">Body</a></h2>
<p>There are different ways to define a http response. We'll just focus here on supplying hardcoded values in the response,
but you can relax all those fields with templates. We'll see that immediately in the next chapter.</p>
<pre><code class="language-json">{
  &quot;response&quot;: {
    &quot;body&quot;: &quot;Hello World !&quot;,
    &quot;base64Body&quot;: &quot;AQID&quot;,
    &quot;bodyFileName&quot;: &quot;tests/stubs/response.json&quot;,
    &quot;jsonBody&quot;: {
      &quot;name&quot;: &quot;john&quot;,
      &quot;surnames&quot;: [
        &quot;jdoe&quot;,
        &quot;johnny&quot;
      ]
    }
  }
}
</code></pre>
<ul>
<li><code>body</code> use this one if you have a text body or anything simple. If the body is large you'd better opt
for <code>bodyFileName</code>.</li>
<li><code>base64Body</code> if the body is not utf-8 encoded use it to supply a body as byte. Those have to be base 64 encoded.</li>
<li><code>bodyFileName</code> when the response gets large or to factorize some very common bodies, it is sometimes preferable to
extract it in a file. When using it in a Rust project, the file path is relative to the workspace root.</li>
<li><code>jsonBody</code> when the body is json. Even though such a body can be defined with all the previous fields, it is more
convenient to define a json response body here.</li>
</ul>
<h2 id="relaxed-field"><a class="header" href="#relaxed-field">Relaxed field</a></h2>
<p>Using only hardcoded values is a good way to start mocking things. But as time goes on, your project might start to get
bloated with a lot of stubs. You will also see the limit of hardcoded values when
doing <a href="stubs/../contract/index.html">contract testing</a>.</p>
<p>In order to &quot;relax&quot; your stub, you will have to use <a href="https://handlebarsjs.com/">Handlebars</a> helpers. They will allow you
to have random values generated for you, because, most of the time, that's what the actual application does. And, as a
consumer, you also don't care about the actual value of this field in your test i.e. <code>&quot;age&quot;: &quot;{{anyU8}}&quot;</code> will work in
all your unit tests because none of your unit tests expects a particular value for this field.</p>
<p>In order to use a Handlebars helper, you need to add <code>&quot;transformers&quot;: [&quot;response-template&quot;]</code>.</p>
<p>Keep in mind that such helper will also be used to generate assertions when you will be using this stub
for <a href="stubs/../contract/index.html">contract testing</a> while <a href="stubs/../contract/producer.html">verifying your producer</a>.</p>
<p>NB: those templates are not available in <a href="https://github.com/tomakehurst/wiremock">Wiremock</a>, you can only use them in
stubr.</p>
<pre><code class="language-json">{
  &quot;response&quot;: {
    &quot;transformers&quot;: [
      &quot;response-template&quot;
    ],
    &quot;jsonBody&quot;: {
      &quot;regex&quot;: &quot;{{anyRegex '[a-z]{4}'}}&quot;,
      &quot;string&quot;: &quot;{{anyNonEmptyString}}&quot;,
      &quot;alphanum&quot;: &quot;{{anyAlphaNumeric}}&quot;,
      &quot;boolean&quot;: &quot;{{anyBoolean}}&quot;,
      &quot;uuid&quot;: &quot;{{anyUuid}}&quot;,
      &quot;ip&quot;: &quot;{{anyIpAddress}}&quot;,
      &quot;host&quot;: &quot;{{anyHostname}}&quot;,
      &quot;email&quot;: &quot;{{anyEmail}}&quot;,
      &quot;enum&quot;: &quot;{{anyOf 'alpha' 'beta' 'gamma'}}&quot;,
      &quot;number&quot;: &quot;{{anyNumber}}&quot;,
      &quot;integer&quot;: &quot;{{anyI32}}&quot;,
      &quot;float&quot;: &quot;{{anyFloat}}&quot;,
      &quot;anyDate&quot;: &quot;{{anyDate}}&quot;
    }
  }
}
</code></pre>
<ul>
<li><code>anyRegex</code> generates a value matching this regex. Tip: most of the time will be used for strings but if this regex
defines an integer, a float or a boolean and is used in <code>&quot;jsonBody&quot;&quot;</code> the generated value will be cast</li>
<li><code>anyNonEmptyString</code> or <code>anyNonBlankString</code> generates an arbitrary utf-8 string</li>
<li><code>anyAlphaNumeric</code> generates an arbitrary string with only alphanumeric characters</li>
<li><code>anyBoolean</code> generates either <code>true</code> or <code>false</code></li>
<li><code>anyUuid</code> generates a random UUIDv4</li>
<li><code>anyIpAddress</code> generates a random IP address e.g. <code>127.0.0.1</code></li>
<li><code>anyHostname</code> generates an arbitrary hostname e.g. <code>https://github.com</code></li>
<li><code>anyEmail</code> generates a random valid email address e.g. <code>john.doe@gmail.com</code></li>
<li><code>anyOf</code> given the supplied values, will pick one randomly. Only works for strings.</li>
<li><code>anyNumber</code> when one does not care about the number size, generates either an integer or a float</li>
<li><code>anyI32</code> or <code>anyU32</code> etc.. generates a random integer. Possible values
are [<code>anyU64</code>, <code>anyI64</code>, <code>anyU32</code>, <code>anyI32</code>, <code>anyU16</code>, <code>anyI16</code>, <code>anyU8</code>, <code>anyI8</code>]</li>
<li><code>anyFloat</code> generates a random float</li>
<li><code>anyDate</code> generates a date with format <code>yyyy-mm-dd</code></li>
<li><code>anyTime</code> generates a time with format <code>hh:mm:ss</code></li>
<li><code>anyDatetime</code> generates a datetime with format <code>yyyy-mm-ddThh:mm:ss</code></li>
<li><code>anyIso8601</code> generates an <a href="https://en.wikipedia.org/wiki/ISO_8601">iso-8601</a> compliant datetime</li>
</ul>
<h2 id="response-templating"><a class="header" href="#response-templating">Response templating</a></h2>
<p>Another kind of relaxing you can do is by being able to represent as best as possible the actual http response of your
app. Very often, a field in the response is the exact same as the one in the request e.g. in a POST request to create
a REST resource. You can use in your response parts of the request to do so.</p>
<pre><code class="language-json">{
  &quot;response&quot;: {
    &quot;transformers&quot;: [
      &quot;response-template&quot;
    ],
    &quot;jsonBody&quot;: {
      &quot;url-path-and-query&quot;: &quot;{{request.url}}&quot;,
      &quot;url-path&quot;: &quot;{{request.path}}&quot;,
      &quot;url-path-segments&quot;: &quot;{{request.pathSegments.[1]}}&quot;,
      &quot;query&quot;: &quot;{{request.query.kind}}&quot;,
      &quot;multi-query&quot;: &quot;{{request.query.kind.[1]}}&quot;,
      &quot;method&quot;: &quot;{{request.method}}&quot;,
      &quot;header&quot;: &quot;{{request.headers.Content-Type}}&quot;,
      &quot;multi-header&quot;: &quot;{{request.headers.cache-control.[0]}}&quot;,
      &quot;body&quot;: &quot;{{request.body}}&quot;,
      &quot;from-request&quot;: &quot;{{jsonPath request.body '$.name'}}&quot;
    }
  }
}
</code></pre>
<ul>
<li><code>request.url</code> given a request to <code>http://localhost/api/path?a=b</code> returns <code>path?a=b</code></li>
<li><code>request.path</code> given a request to <code>http://localhost/api/path?a=b</code> returns <code>api/path</code></li>
<li><code>request.pathSegments.[i]</code> allows picking a part of the url path (<code>i</code> is zero indexed) e.g.
<code>http://localhost/a/b/c</code> with <code>i</code> == 1 returns <code>b</code></li>
<li><code>query.&lt;selector&gt;.[i]</code> allows picking a named query parameter. Replace <code>&lt;selector&gt;</code> by the name of the query
parameter. If the query parameter is multivalued, you can select only one with the zero indexed <code>i</code>. For example with
<code>http://localhost?a=1&amp;a=2&amp;a=3&amp;b=1</code> then <code>{{query.b}}</code> returns <code>1</code> and <code>{{query.a.[1]}}</code> returns <code>2</code></li>
<li><code>request.method</code> returns the (uppercase) http request method. If you want the lowercase method
just <code>{{lower request.method}}</code></li>
<li><code>request.headers.&lt;selector&gt;.[i]</code> about the same as picking query parameters. Note that here <code>selector</code> is
case-insensitive.</li>
<li><code>request.body</code> takes the raw request body without altering it</li>
<li><code>jsonPath request.body '&lt;json-path&gt;'</code> for templating only a field from request's json body. <code>json-path</code> is the
JSONPath
for selecting the right field. Use an <a href="https://jsonpath.com/">online JSONPath evaluator</a> to try out your paths.</li>
</ul>
<p>You also sometimes have to generate dynamic data or to transform existing one:</p>
<pre><code class="language-json">{
  &quot;response&quot;: {
    &quot;transformers&quot;: [
      &quot;response-template&quot;
    ],
    &quot;jsonBody&quot;: {
      &quot;now&quot;: &quot;{{now}}&quot;,
      &quot;now-fmt&quot;: &quot;{{now format='yyyy/MM/dd'}}&quot;,
      &quot;now-fmt-epoch&quot;: &quot;{{now format='epoch'}}&quot;,
      &quot;now-fmt-unix&quot;: &quot;{{now format='unix'}}&quot;,
      &quot;now-positive-offset&quot;: &quot;{{now offset='3 days'}}&quot;,
      &quot;now-negative-offset&quot;: &quot;{{now offset='-3 days'}}&quot;,
      &quot;now-with-timezone&quot;: &quot;{{now timezone='Europe/Rome'}}&quot;,
      &quot;number-is-odd&quot;: &quot;{{isOdd request.body}}&quot;,
      &quot;number-stripes&quot;: &quot;{{stripes request.body 'if-even' 'if-odd'}}&quot;,
      &quot;string-capitalized&quot;: &quot;{{capitalize request.body}}&quot;,
      &quot;string-uppercase&quot;: &quot;{{upper request.body}}&quot;,
      &quot;string-trim&quot;: &quot;{{trim request.body}}&quot;,
      &quot;size&quot;: &quot;{{size request.body}}&quot;,
      &quot;base64-encode&quot;: &quot;{{base64 request.body padding=false}}&quot;,
      &quot;base64-decode&quot;: &quot;{{base64 request.body decode=true}}&quot;,
      &quot;url-encode&quot;: &quot;{{urlEncode request.header.x-raw}}&quot;,
      &quot;url-decode&quot;: &quot;{{urlEncode request.header.x-encoded decode=true}}&quot;
    }
  }
}
</code></pre>
<ul>
<li><code>now</code> by default return the current datetime in <a href="https://www.rfc-editor.org/rfc/rfc3339">RFC 3339</a> format (this is
only for backward compatibility with Wiremock)
<ul>
<li><code>format</code> could be either:
<ul>
<li>a custom <a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html">Java SimpleDateFormat</a> (
for Wiremock compatibility) e.g. <code>format='yyyy/MM/dd'</code></li>
<li><code>epoch</code> Unix timestamp in milliseconds</li>
<li><code>unix</code> Unix timestamp in seconds</li>
</ul>
</li>
<li><code>offset</code> now with the given offset expressed in human-readable format. Refer
to <a href="https://docs.rs/humantime/latest/humantime/fn.parse_duration.html">humantime documentation</a> for further
examples.</li>
<li><code>timezone</code> for using a string timezone (
see <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List">list</a>)</li>
</ul>
</li>
<li><code>isOdd</code> or <code>isEven</code> returns a boolean whether the numeric value is an even or odd integer</li>
<li><code>capitalize</code> first letter to uppercase e.g. <code>mister</code> becomes <code>Mister</code></li>
<li><code>upper</code> or <code>lower</code> recapitalizes the whole word</li>
<li><code>stripes</code> returns alternate values depending if the tested value is even or odd</li>
<li><code>trim</code> removes leading &amp; trailing whitespaces</li>
<li><code>size</code> returns the number of bytes for a string (‚ö†Ô∏è not the number of characters) or the size of an array</li>
<li><code>base64</code> for standard (no base64 url encoding yet) Base64 encoding
<ul>
<li><code>decode</code> for decoding when true</li>
<li><code>padding</code> with/without padding</li>
</ul>
</li>
<li><code>urlEncode</code> for url encoding the value. Use <code>decode=true</code> to decode</li>
</ul>
<h2 id="simulate-fault"><a class="header" href="#simulate-fault">Simulate fault</a></h2>
<p>You can also use stubr to simulate http server runtime behaviour. And most of the time you'll want to introduce
latencies
to check how your consuming application reacts to such delays. Currently, the options are quite sparse but should grow !</p>
<pre><code class="language-json">{
  &quot;expect&quot;: 2,
  &quot;response&quot;: {
    &quot;fixedDelayMilliseconds&quot;: 2000
  }
}
</code></pre>
<ul>
<li><code>expect</code> will allow to verify that your unit test has not called the given stub more than N times. Turn it on like
this <code>stubr::Stubr::start_with(stubr::Config { verify: true, ..Default::default() })</code>
or <code>#[stubr::mock(verify = true)]</code> with the attribute macro</li>
<li><code>fixedDelayMilliseconds</code> a delay (in milliseconds) added everytime this stub is matched. If you are using stubr
standalone through the <a href="stubs/../cli.html">cli</a>, this value can be either superseded by <code>--delay</code> or complemented
by <code>--latency</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording"><a class="header" href="#recording">Recording</a></h1>
<p>Writing stubs by hand can be... well, painful. More often than not, you already have an existing app ready and you just
want to mock it for consumers. Or you are from those who prefer writing code before tests. Or you are lazy üòÖ.</p>
<p>All those are valid reasons and in order to help you with that, you can record real http traffic and turn it into json
stub files. If you are not at all working on Rust projects, you can <a href="recording/cli.html">record using the cli</a> to capture traffic
from for example a real application in production written in Java. If you are in a Rust project and use a http client
library, you can record its traffic in tests for <a href="recording/actix.html">actix</a>, <a href="recording/isahc.html">isahc</a> or <a href="recording/reqwest.html">reqwest</a>. And
if your favorite http client is not is this list you can still record using a <a href="recording/standalone.html">standalone</a> recorder. 
Recording in a Rust consumer is mostly about getting faster, especially with &quot;fat&quot; endpoints with hundreds of fields. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording-your-actix-app"><a class="header" href="#recording-your-actix-app">Recording your actix app</a></h1>
<p>You can plug recording in your existing <a href="https://actix.rs/docs/testing/#integration-tests">actix integration tests</a> by 
just adding a single line: <code>.wrap(stubr::ActixRecord::default())</code>. This will register a middleware which will capture
the http request and response, then dump them under <code>./target/stubs/localhost</code>.</p>
<p><em>This requires the <code>record-actix</code> feature.</em></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::test::{call_service, init_service, TestRequest};
use asserhttp::*;

#[actix_web::test]
async fn record_actix() {
    let app = actix_web::App::new()
        .route(&quot;/&quot;, actix_web::web::get().to(|| async { actix_web::HttpResponse::Ok().await }))
        // just add this üëá
        .wrap(stubr::ActixRecord::default()); // or `ActixRecord(RecordConfig)` for configuring it
    let req = TestRequest::get().uri(&quot;/&quot;).to_request();
    let svc = init_service(app).await;
    call_service(&amp;svc, req).await.expect_status_ok();
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording-with-the-cli"><a class="header" href="#recording-with-the-cli">Recording with the cli</a></h1>
<p>In order to record http traffic, <code>stubr</code> can act as a proxy to dump this traffic into json stubs on your local
filesystem. Recording can be started with the <code>stubr record</code> command. Stubs will be grouped by hosts. You can then play
them back using <code>stubr</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>arg</th><th style="text-align: center">about</th><th style="text-align: center">examples</th></tr></thead><tbody>
<tr><td><code>--port</code></td><td style="text-align: center">Proxy port. Defaults to 3030.</td><td style="text-align: center"><code>stubr --port 3031</code> or <code>stubr -p 3031</code></td></tr>
<tr><td><code>--output</code></td><td style="text-align: center">File path where recorded stubs are stored. Default to current directory.</td><td style="text-align: center"><code>stubr --port record-1</code> or <code>stubr -o record-1</code></td></tr>
</tbody></table>
</div>
<h3 id="example"><a class="header" href="#example">example</a></h3>
<p>First, start stubr recorder on port <code>3030</code>. It will act as a proxy.</p>
<pre><code class="language-bash">stubr record -p 3030
</code></pre>
<p>We are going to consume a publicly available endpoint returning a list of sample users. We'll use <a href="https://curl.se/">curl</a>
to make this http call, and we will configure it to use our recorder as a proxy.</p>
<pre><code class="language-bash">curl jsonplaceholder.typicode.com/users --proxy http://localhost:3030
</code></pre>
<p>You should have a stub under <code>jsonplaceholder.typicode.com/users-*.json</code> following the pattern <code>{domain}/{path}-{md5-hash}.json</code>.</p>
<p>NB: <em>That way of recording is less intrusive than <a href="https://wiremock.org/docs/record-playback/">if you had to do it with wiremock,</a>
and you can configure. Most of the tools e.g. <a href="https://curl.se/">curl</a>, <a href="https://jmeter.apache.org/">JMeter</a>, <a href="https://k6.io/">k6</a> or
simply your web browser support configuring a http proxy (and more often than not, just by setting an environment variable,
leaving your tests/scripts untouched).</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording-your-isahc-calls"><a class="header" href="#recording-your-isahc-calls">Recording your isahc calls</a></h1>
<p>The only way currently to record isahc is to spawn a proxy and configure isahc to use this proxy. This is exactly what
the following snippet does.</p>
<p><em>This requires the <code>record-isahc</code> feature.</em></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use asserhttp::*;

#[tokio::test(flavor = &quot;multi_thread&quot;)] // üëà required by recording proxy
#[stubr::mock(&quot;ping.json&quot;)] // üëà spawn a mock server
async fn record_isahc() {
    // üëá spawn the recording proxy
    stubr::Stubr::record() // or `record_with()` for configuring it
        // üëá builds an isahc client with proxy configured
        .isahc_client()
        .get(stubr.uri())
        .expect_status_ok();
}
<span class="boring">}
</span></code></pre></pre>
<p>You can find your recorded stubs under <code>./target/stubs/localhost</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording-your-reqwest-calls"><a class="header" href="#recording-your-reqwest-calls">Recording your reqwest calls</a></h1>
<p>You have 2 ways to record reqwest http calls ; either with the <code>stubr::Record</code> trait (highly recommended) or the &quot;original&quot;
way, still supported, with a standalone recording proxy.</p>
<p><em>This requires the <code>record-reqwest</code> feature.</em></p>
<h2 id="trait-recommended"><a class="header" href="#trait-recommended">trait (recommended)</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use asserhttp::*;
use stubr::Record as _;

#[test]
#[stubr::mock(&quot;ping.json&quot;)] // üëà spawn a mock server
fn record_reqwest_trait() {
    // recording unfortunately requires using reqwest's builder hence the syntax is a bit verbose
    let req = reqwest::blocking::ClientBuilder::new().build().unwrap()
        .get(stubr.uri())
        // üëá this will intercept and dump all http traffic going through this client
        .record() // or `record_with()` for configuring it
        .build().unwrap();
    reqwest::blocking::Client::default().execute(req).unwrap()
        .expect_status_ok();
}
<span class="boring">}
</span></code></pre></pre>
<p>You can find your recorded stubs under <code>./target/stubs/localhost</code></p>
<p><em>NB: async is not supported yet</em></p>
<h2 id="standalone"><a class="header" href="#standalone">standalone</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use asserhttp::*;

#[tokio::test(flavor = &quot;multi_thread&quot;)] // üëà required by recording proxy
#[stubr::mock(&quot;ping.json&quot;)] // üëà spawn a mock server
async fn record_reqwest() {
    // üëá spawn the recording proxy
    stubr::Stubr::record() // or `record_with()` for configuring it
        // üëá builds a reqwest client with proxy configured
        .reqwest_client()
        .get(stubr.uri()).send().await
        .expect_status_ok();
}
<span class="boring">}
</span></code></pre></pre>
<p>You can find your recorded stubs under <code>./target/stubs/localhost</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording-standalone"><a class="header" href="#recording-standalone">Recording standalone</a></h1>
<p>If you don't fall into one of the previous boxes (for example if you use another http client), you can still record the http
traffic by using the standalone recording proxy, the exact same one used in the <a href="recording/../cli.html">cli</a>.</p>
<p>To do so, you just have to spawn the proxy and then configure your http client to use this proxy.</p>
<p><em>This requires the <code>record</code> feature.</em></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn record_standalone() {
    // üëá spawn the recording proxy
    let proxy = stubr::Stubr::record(); // works for async as well
    // or use `record_with()` for configuring it
    let _proxy_uri = proxy.uri();
    // ‚òùÔ∏è then use this uri to configure your http client
}
<span class="boring">}
</span></code></pre></pre>
<p>Or, in order to keep the syntax short, you can use the provided attribute macro.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// works for async as well
#[stubr::record] // üëà this spawns the proxy and creates a 'recorder' binding in the function
// #[stubr::record(port = 1234)] for setting a port
#[test]
fn record_standalone() {
    let _proxy_uri = recorder.uri();
    // ‚òùÔ∏è then use this uri to configure your http client
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli"><a class="header" href="#cli">Cli</a></h1>
<p>You can use <code>stubr</code> as a cli for serving Wiremock stubs on a local server or as proxy for recording http traffic into
json stubs.</p>
<p>To get a list of all available options run <code>stubr --help</code></p>
<div class="table-wrapper"><table><thead><tr><th>arg</th><th style="text-align: center">about</th><th style="text-align: center">examples</th></tr></thead><tbody>
<tr><td><code>[dir]</code></td><td style="text-align: center">Folder containing stubs or individual stub.</td><td style="text-align: center"><code>stubr ./my-app-stubs</code> or <code>stubr ./my-app-stubs/ping.json</code></td></tr>
<tr><td><code>--root-dir</code></td><td style="text-align: center">Directory containing a <code>mappings</code> folder with all stubs. Equivalent to Wiremock's one. Has precedence over <code>[dir]</code></td><td style="text-align: center"><code>stubr --root-dir ./my-app-stubs</code></td></tr>
<tr><td><code>--port</code></td><td style="text-align: center">Server port. Defaults to random port.</td><td style="text-align: center"><code>stubr --port 8080</code> or <code>stubr -p 8080</code></td></tr>
<tr><td><code>--delay</code></td><td style="text-align: center">Global delay duration applied to all stubs (supersedes any locally defined delay).</td><td style="text-align: center"><code>stubr --delay 2s</code> or <code>stubr -d 1m</code> or <code>stubr -d 100ms</code></td></tr>
<tr><td><code>--latency</code></td><td style="text-align: center">Delay added to any locally defined delay. Simulates network latency.</td><td style="text-align: center"><code>stubr --latency 2s</code> or <code>stubr -l 1m</code> or <code>stubr -l 100ms</code></td></tr>
<tr><td><code>completion</code></td><td style="text-align: center">Generates &amp; installs bash or zsh completion scripts</td><td style="text-align: center"><code>stubr completion bash</code> or <code>stubr completion zsh</code></td></tr>
<tr><td><code>--help</code></td><td style="text-align: center">Displays help.</td><td style="text-align: center"><code>stubr help</code> or <code>stubr -h</code> for short help. <code>stubr --help</code> for long help</td></tr>
<tr><td><code>--version</code></td><td style="text-align: center">Displays <code>stubr</code> version.</td><td style="text-align: center"><code>stubr -V</code> or <code>stubr --version</code></td></tr>
</tbody></table>
</div>
<h2 id="install-it"><a class="header" href="#install-it">install it</a></h2>
<h3 id="precompiled-binaries"><a class="header" href="#precompiled-binaries">precompiled binaries</a></h3>
<p>If you don't want to install <a href="https://rustup.rs/">Rust toolchain</a>, you can always download precompiled binaries. They
have the advantage of being optimized with <a href="https://upx.github.io/">upx</a> hence they are just smaller than the ones you'd
get from sources.</p>
<h4 id="linux-1"><a class="header" href="#linux-1">linux:</a></h4>
<pre><code class="language-bash">curl -L https://github.com/beltram/stubr/releases/latest/download/stubr-linux.tar.gz | tar xz - -C /usr/local/bin
</code></pre>
<h4 id="macos-1"><a class="header" href="#macos-1">macos:</a></h4>
<pre><code class="language-bash">curl -L https://github.com/beltram/stubr/releases/latest/download/stubr-macos.tar.gz | tar xz - -C /usr/local/bin
</code></pre>
<h3 id="from-source"><a class="header" href="#from-source">from source</a></h3>
<pre><code class="language-bash">cargo install stubr-cli
</code></pre>
<h3 id="once-installed-generate-completion"><a class="header" href="#once-installed-generate-completion">once installed, generate completion</a></h3>
<p>Completion files generation is currently supported for <code>bash</code> and <code>zsh</code>. Stubr cli provides a <code>completion</code> command to
generate and install them in a standard location.</p>
<pre><code class="language-bash">stubr completion zsh
# or
stubr completion bash
</code></pre>
<h2 id="getting-started-2"><a class="header" href="#getting-started-2">getting started</a></h2>
<p>The simplest usage is for serving Wiremock stubs under a directory (or just a single file).<br />
For example let's generate a simple stub file.</p>
<pre><code class="language-bash">echo &quot;{\&quot;request\&quot;: {\&quot;method\&quot;: \&quot;GET\&quot;}, \&quot;response\&quot;: { \&quot;status\&quot;: 200 }}&quot; &gt; hello.json
</code></pre>
<p>Then simply run it with the following command.</p>
<pre><code class="language-bash">stubr hello.json
</code></pre>
<p>Which will generate something like that.</p>
<pre><code class="language-bash"> &gt; + mounted &quot;hello.json&quot;
 &gt; Started stubr in 50ms on http://127.0.0.1:49604
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker"><a class="header" href="#docker">Docker</a></h1>
<p>A docker image is published <a href="https://github.com/users/beltram/packages/container/package/stubr">here</a> with each release.</p>
<p>You can play with it with the following commands:</p>
<pre><code class="language-bash">echo &quot;{\&quot;request\&quot;: {\&quot;method\&quot;: \&quot;GET\&quot;}, \&quot;response\&quot;: { \&quot;body\&quot;: \&quot;Hello stubr\&quot; }}&quot; &gt; hello.json &amp;&amp;
docker run -v $(pwd):/stubs -d --rm -p 8080:8080 ghcr.io/beltram/stubr:latest /stubs -p 8080 &amp;&amp;
http :8080
</code></pre>
<p>Which should output</p>
<pre><code class="language-bash">HTTP/1.1 200 OK
content-length: 11
content-type: text/plain
date: Tue, 23 Mar 2021 13:37:41 GMT
server: stubr(0.5.0-rc.2)

Hello stubr
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benchmark"><a class="header" href="#benchmark">Benchmark</a></h1>
<h2 id="vs-wiremock"><a class="header" href="#vs-wiremock">vs wiremock</a></h2>
<p>A very simple benchmark comparing stubr to wiremock is
available <a href="https://github.com/beltram/stubr/blob/main/bench/README.md">here</a></p>
<h2 id="standalone-1"><a class="header" href="#standalone-1">standalone</a></h2>
<p>A benchmark of <code>stubr</code> itself, powered by <a href="https://crates.io/crates/criterion">criterion</a> is available for each release.
The latest is available <a href="https://github.com/beltram/stubr/releases/latest/download/bench.tar.gz">here</a>. It aims at
tracking down progresses/regressions made.</p>
<p>I'm still looking for a way to turn this into something more ergonomic, especially I'd like to provide a way to compare
2 benchmarks. Meanwhile, you can download the latest benchmark with these commands.</p>
<pre><code class="language-bash">mkdir stubr-bench &amp;&amp;
curl -L https://github.com/beltram/stubr/releases/latest/download/bench.tar.gz | tar xz - -C stubr-bench
</code></pre>
<p>Then open <code>./stubr-bench/report/index.html</code> in your browser.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ide-completion"><a class="header" href="#ide-completion">IDE completion</a></h1>
<p>A json schema is also maintained <a href="schemas/stubr.schema.json">here</a> to provide completion in IDE. It just contains
completion for features implemented in stubr and should alleviate you from a bit of pain when writing json from scratch.</p>
<details>
<summary><b>IntelliJ</b></summary>
<ul>
<li>Go to <code>Settings &gt; Languages &amp; Frameworks &gt; Schemas &amp; DTDs &gt; JSON Schema Mappings</code></li>
<li>Add a mapping (click on the upper <code>+</code>)</li>
<li>Then supply the following
<ul>
<li>name: <code>stubr</code></li>
<li>Schema file or URL: <code>https://raw.githubusercontent.com/beltram/stubr/main/schemas/stubr.schema.json</code></li>
<li>Schema version: <code>JSON Schema version 7</code></li>
<li>File path pattern: <code>stubs/*.json</code> (and <code>mappings/*.json</code> if you want to use it for original wiremock stubs)</li>
</ul>
</li>
<li>Then <code>Apply</code></li>
</ul>
</details>
<details>
<summary><b>VsCode</b></summary>
<ul>
<li>Open workspace settings (File &gt; Preferences &gt; Settings)</li>
<li>Add the following under the property <code>json.schemas</code></li>
</ul>
<pre><code class="language-json">&quot;json.schemas&quot;: [{&quot;fileMatch&quot;: [&quot;stubs/*.json&quot;, &quot;mappings/*.json&quot;], &quot;url&quot;: &quot;https://raw.githubusercontent.com/beltram/stubr/main/schemas/stubr.schema.json&quot;}]
</code></pre>
</details>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
