<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>stubr</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">2.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="stubbing.html"><strong aria-hidden="true">3.</strong> Stubbing</a></li><li class="chapter-item expanded "><a href="contract/index.html"><strong aria-hidden="true">4.</strong> Contract Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contract/producer.html"><strong aria-hidden="true">4.1.</strong> As a producer</a></li><li class="chapter-item expanded "><a href="contract/consumer.html"><strong aria-hidden="true">4.2.</strong> As a consumer</a></li></ol></li><li class="chapter-item expanded "><a href="stubs/index.html"><strong aria-hidden="true">5.</strong> Writing Stubs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="stubs/request.html"><strong aria-hidden="true">5.1.</strong> Request</a></li><li class="chapter-item expanded "><a href="stubs/response.html"><strong aria-hidden="true">5.2.</strong> Response</a></li><li class="chapter-item expanded "><a href="stubs/relaxing.html"><strong aria-hidden="true">5.3.</strong> Relaxing</a></li></ol></li><li class="chapter-item expanded "><a href="recording/index.html"><strong aria-hidden="true">6.</strong> Recording</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="recording/actix.html"><strong aria-hidden="true">6.1.</strong> Actix</a></li><li class="chapter-item expanded "><a href="recording/cli.html"><strong aria-hidden="true">6.2.</strong> Cli</a></li><li class="chapter-item expanded "><a href="recording/isahc.html"><strong aria-hidden="true">6.3.</strong> isahc</a></li><li class="chapter-item expanded "><a href="recording/reqwest.html"><strong aria-hidden="true">6.4.</strong> reqwest</a></li><li class="chapter-item expanded "><a href="recording/standalone.html"><strong aria-hidden="true">6.5.</strong> standalone</a></li></ol></li><li class="chapter-item expanded "><a href="cli.html"><strong aria-hidden="true">7.</strong> Cli</a></li><li class="chapter-item expanded "><a href="docker.html"><strong aria-hidden="true">8.</strong> Docker</a></li><li class="chapter-item expanded "><a href="ide-completion.html"><strong aria-hidden="true">9.</strong> IDE completion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">stubr</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="stubr"><a class="header" href="#stubr">Stubr</a></h1>
<p>Stubr is a stubbing and contract testing tool. It supports the same API for writing stubs
as <a href="https://github.com/tomakehurst/wiremock">Wiremock</a>.
You can also see it as an adaptation of <a href="https://github.com/LukeMathWalker/wiremock-rs">wiremock-rs</a> with the ability to
write stubs as json files instead of code.</p>
<p>You might ask <strong>why would I want to do such a thing ?</strong> After all, code is a great way to write stubs. That's true ! But
it also comes with some limitations: <strong>it is hard to share.</strong> And it especially starts tickling your attention when you
try to do <a href="https://martinfowler.com/bliki/ContractTest.html">contract testing</a>. You have to share a <code>contract</code> between a
producer and a consumer. Sometimes, both are written in different languages, or with different frameworks ; and even
when that's not the case, they might both be sharing a different version of that wicked dependency which clash together.
Having your contract written in json has the benefits of being <strong>portable</strong>, <strong>lightweight</strong> and <strong>polyglot</strong> (if you
stick to a
standard API such as Wiremock's one). So you could for example test a producer service written in Java and vice versa !</p>
<p>Stubr aims at bridging multiple languages and framework and enable developers to test their integration with remote
application without having to mock their own code. It also enables them to shorten their feedback loop: no need for a
complex CI to make sure 2 application share the same API definition, everything can be done offline.</p>
<p>Then, beyond <a href="contract/index.html">contract testing</a>, it tries to cover others areas:</p>
<ul>
<li><a href="stubbing.html">stubbing</a> in your Rust project for simulating remote services your app depends on</li>
<li><a href="recording/index.html">recording</a> for capturing http traffic and turning it into a stub file</li>
<li>standalone for running stubr stub server from anywhere and benefiting from Rust performances. Available as
a <a href="cli.html">cli</a> or a <a href="docker.html">Docker image</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>For this short demo we are going to create a http stub, mount it in a stub server and then call it to verify it works.</p>
<h2 id="installation"><a class="header" href="#installation">installation</a></h2>
<h4 id="recommended"><a class="header" href="#recommended">recommended</a></h4>
<p><em>If you don't have it, install rustup from <a href="https://rustup.rs/">here</a>.</em></p>
<pre><code class="language-bash">cargo install stubr-cli
</code></pre>
<h4 id="or-from-precompiled-binaries"><a class="header" href="#or-from-precompiled-binaries">or from precompiled binaries</a></h4>
<p>Those binaries are stripped with <a href="https://upx.github.io/">upx</a> and then compressed. They are likely to be smaller than
the ones built by rustc which might be preferable in certain conditions</p>
<h6 id="macos"><a class="header" href="#macos">macos</a></h6>
<pre><code class="language-bash">curl -L https://github.com/beltram/stubr/releases/latest/download/stubr-macos.tar.gz | tar xz - -C /usr/local/bin
</code></pre>
<h6 id="linux"><a class="header" href="#linux">linux</a></h6>
<pre><code class="language-bash">curl -L https://github.com/beltram/stubr/releases/latest/download/stubr-linux.tar.gz | tar xz - -C /usr/local/bin
</code></pre>
<h6 id="windows"><a class="header" href="#windows">windows</a></h6>
<p>Install binary from <a href="https://github.com/beltram/stubr/releases/latest/download/stubr-windozs.zip">here</a>.</p>
<h2 id="hello-world-"><a class="header" href="#hello-world-">Hello world !</a></h2>
<p>We are going to create the simplest stub possible. It will accept any http method on any path and will respond <code>200 OK</code>.</p>
<pre><code class="language-bash">cat &gt; stub.json &lt;&lt;- EOF
{
  &quot;request&quot;: {
    &quot;method&quot;: &quot;ANY&quot;
  },
  &quot;response&quot;: {
    &quot;status&quot;: 200,
    &quot;body&quot;: &quot;Hello world !&quot;,
  }
}
EOF
</code></pre>
<p>A few things about a stub:</p>
<ul>
<li>It is a json file. First because it is the format supported by <a href="https://github.com/tomakehurst/wiremock">Wiremock</a> and
we want to be compatible with it. Also, most of the time, your http APIs will consume/produce json data in their
bodies. So you can inline the request/response body in this file without externalizing it.</li>
<li><code>request { .. }</code> is where we define <strong>request matching</strong> i.e. &quot;<em>conditions the incoming http request has to satisfy in
order for the response part to be served</em>&quot;</li>
<li><code>response { .. }</code> is the part where you define what the stub server will respond if all request matchings pass.</li>
</ul>
<h4 id="mount-it"><a class="header" href="#mount-it">mount it</a></h4>
<p>The cli can spawn a http server with a path to the file or folder containing json stubs. By default, it will try to bind
to a random port, here we force it to attach to port <code>8080</code>.</p>
<pre><code class="language-bash">stubr stub.json -p 8080 &amp;
</code></pre>
<h4 id="call-it"><a class="header" href="#call-it">call it</a></h4>
<p>Now let's verify our stub server is up and running and that it serves our stubs the right way.</p>
<pre><code class="language-bash">curl -i http://localhost:8080
</code></pre>
<p>Which should output:</p>
<pre><code class="language-bash">HTTP/1.1 200 OK
server: stubr(0.4.14)
content-length: 0
date: Fri, 22 Jul 2022 19:31:48 GMT

Hello world !%
</code></pre>
<p>or with httpie</p>
<pre><code class="language-bash">http :8080
</code></pre>
<h2 id="hello-name-"><a class="header" href="#hello-name-">Hello {name} !</a></h2>
<p>Now let's spice things a bit and make our stub a bit more dynamic by capturing a part of the request path and template
it in the response (this is called <a href="stubs/response-templating.html">response templating</a>).</p>
<p>But first let's kill the previous server</p>
<pre><code class="language-bash">lsof -ti tcp:8080 | xargs kill
</code></pre>
<pre><code class="language-bash">cat &gt; hello.json &lt;&lt;- EOF
{
  &quot;request&quot;: {
    &quot;method&quot;: &quot;GET&quot;,
    &quot;urlPathPattern&quot;: &quot;/hello/(.+)&quot;
  },
  &quot;response&quot;: {
    &quot;status&quot;: 200,
    &quot;body&quot;: &quot;Hello {{request.pathSegments.[1]}} !&quot;,
    &quot;transformers&quot;: [&quot;response-template&quot;]
  }
}
EOF
</code></pre>
<p>Here:</p>
<ul>
<li><code>&quot;urlPathPattern&quot;: &quot;/hello/(.+)&quot;</code> is one way to express URL matching. It contains a regular hardcoded path <code>/hello/</code>
and a regular expression <code>(.+)</code> which has to match in order for the stub response to be served.</li>
<li><code>&quot;transformers&quot;: [&quot;response-template&quot;]</code> will activate response templating. This allows you to inject a part of the
request in the response. Prefer using it over hardcoded values when your real life application actually does that. The
more you use it the better your test accuracy will be.</li>
<li><code>{{request.pathSegments.[1]}}</code> now that response templating is enabled, you can inject parts of your request in the
response. With <a href="https://github.com/tomakehurst/wiremock">Wiremock</a> as with stubr, we
use <a href="https://handlebarsjs.com/">handlebars</a> templates to do such a
thing. <a href="stubs/response-templating.html">Many response templates are available</a> in stubr in order to pick whatever part
of the request you want.</li>
</ul>
<h4 id="mount-it-1"><a class="header" href="#mount-it-1">Mount it</a></h4>
<pre><code class="language-bash">stubr hello.json -p 8080 &amp;
</code></pre>
<h4 id="call-it-1"><a class="header" href="#call-it-1">call it</a></h4>
<pre><code class="language-bash">curl -i http://localhost:8080/hello/stubr
</code></pre>
<p>Which should output:</p>
<pre><code class="language-bash">HTTP/1.1 200 OK
server: stubr(0.4.14)
content-type: text/plain
content-length: 13
date: Sat, 23 Jul 2022 09:25:42 GMT

Hello stubr !%
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stubbing"><a class="header" href="#stubbing">Stubbing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="as-a-producer"><a class="header" href="#as-a-producer">As a producer</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="as-a-consumer"><a class="header" href="#as-a-consumer">As a consumer</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stubs"><a class="header" href="#stubs">Stubs</a></h1>
<p>Writing stubs can be challenging and time-consuming. Stubr tries to assist by
providing <a href="stubs/../ide-completion.html">IDE completion</a> or by <a href="stubs/../recording/index.html">recording</a> live traffic into stubs. But
you still have to know how to write a stub and what helpers you have in order to <a href="stubs/relaxing.html">relax</a> your stubs as much
as possible.</p>
<p>You will find here in a single snippet <strong>ALL</strong> the fields/helpers available to you:</p>
<pre><code class="language-json">{
  &quot;id&quot;: &quot;82d86e05-9ee0-44ca-9a8d-1fc6f719437e&quot;, // (optional) unique stub identifier. Returned in 'Matched-Stub-Id' header
  &quot;priority&quot;: 1, // (optional) helps solving interlaced conditions (many stubs match the request). 1 is the highest priority, 255 the lowest
  &quot;request&quot;: {
    &quot;method&quot;: &quot;GET&quot;, // (optional) http method. Can be &quot;ANY&quot; to match any method. Defaults to &quot;ANY&quot;
    &quot;urlPath&quot;: &quot;/api/exact-uri&quot;, // exact URI match
    &quot;urlPathPattern&quot;: &quot;/api/regex-uri/([a-z]{4})&quot;, // URI must match regex
    &quot;urlPattern&quot;: &quot;/api/regex-uri/([a-z]{4})\\?and=([a-z]{4})&quot;, // URI &amp; query must match regex
    &quot;url&quot;: &quot;/api/uri?age=young&quot;, // raw URI + query parameters by equality matching
    &quot;queryParameters&quot;: {
      &quot;firstname&quot;: { &quot;equalTo&quot;: &quot;beltram&quot; }, // by equality matching (can also be an int, or a boolean)
      &quot;lastname&quot;: { &quot;equalTo&quot;: &quot;maldant&quot;, &quot;caseInsensitive&quot;: true }, // case insensitve equality
      &quot;age&quot;: { &quot;absent&quot;: true }, // must be absent
      &quot;city&quot;: { &quot;contains&quot;: &quot;a&quot; }, // must contain the letter 'a'
      &quot;title&quot;: { &quot;matches&quot;: &quot;([A-Za-z]+)&quot; }, // must match regex
      &quot;job&quot;: { &quot;doesNotMatch&quot;: &quot;([A-Za-z]+)&quot; }, // or must not match regex
    },
    &quot;headers&quot;: {
      &quot;content-type&quot;: { &quot;equalTo&quot;: &quot;application/json&quot; } // by equality matching
      // .. then all matchers described above for query parameters are also applicable here
    },
    &quot;basicAuth&quot; : { // exact Basic authentication matching
      &quot;username&quot;: &quot;user&quot;,
      &quot;password&quot;: &quot;pass&quot;
    },
    &quot;jwtAuth&quot;: {
      &quot;equalTo&quot;: &quot;eyJhbGciOiJSUzI1NiJ9.e30.MBkQ...&quot;, // plain JWT token
      &quot;alg&quot;: {
        &quot;equalTo&quot;: &quot;RS256&quot;, // JWT algorithm by equality matcher
        &quot;oneOf&quot;: [&quot;RS256&quot;, &quot;HS256&quot;] // JWT must contain one of these algorithms
      },
      &quot;payloadPatterns&quot;: [
        // all matchers available in 'bodyPatterns' ⬇️
      ]
    },
    &quot;bodyPatterns&quot;: [
      { &quot;equalToJson&quot;: {&quot;name&quot;: &quot;bob&quot;} }, // strict json request body equality
      { &quot;equalToJson&quot;: {&quot;name&quot;: &quot;bob&quot;}, &quot;ignoreExtraElements&quot;: true }, // ignore extra json fields supplied in request body. Default to false.
      { &quot;equalToJson&quot;: {&quot;name&quot;: &quot;bob&quot;}, &quot;ignoreArrayOrder&quot;: true }, // ignore array items order. Default to false.
      { &quot;matchesJsonPath&quot;: &quot;$.name&quot; }, // must just match json path
      { &quot;matchesJsonPath&quot;: &quot;$.consoles[?(@.name == 'xbox')]&quot; }, // must match json path + equality
      { &quot;matchesJsonPath&quot;: &quot;$.consoles[?(@.price &gt; 200)]&quot; }, // must match json path + bound
      { &quot;expression&quot;: &quot;$.name&quot;, &quot;contains&quot;: &quot;at&quot; }, // must match json path + contain the string 'at'
      { &quot;expression&quot;: &quot;$.user&quot;, &quot;equalToJson&quot;: { &quot;name&quot;: &quot;bob&quot; } }, // must match json path + be equal
      { &quot;binaryEqualTo&quot;: &quot;AQID&quot; /* Base 64 */ } // byte array equality
    ]
  },
  &quot;response&quot;: {
    &quot;status&quot;: 200, // (required) response status
    &quot;fixedDelayMilliseconds&quot;: 2000, // delays response by 2 seconds
    &quot;jsonBody&quot;: { // json response body (automatically adds 'content-type:application/json' header)
      &quot;name&quot;: &quot;john&quot;,
      &quot;surnames&quot;: [ &quot;jdoe&quot;, &quot;johnny&quot; ]
    },
    &quot;body&quot;: &quot;Hello World !&quot;, // text response (automatically adds 'Content-Type:text/plain' header)
    &quot;base64Body&quot;: &quot;AQID&quot;, // binary Base 64 body
    &quot;bodyFileName&quot;: &quot;tests/stubs/response.json&quot;, // path to a .json or .txt file containing the response
    &quot;headers&quot;: {
      &quot;content-type&quot;: &quot;application/pdf&quot; // returns this response header
    },
    // ..now response templating
    // it uses handlebars and allows you to define dynamic response based upon the content of the request
    // it can be used in &quot;jsonBody&quot;, &quot;body&quot;, &quot;bodyFileName&quot; or &quot;headers&quot;
    &quot;transformers&quot;: [&quot;response-template&quot;], // required to activate response templating
    &quot;jsonBody&quot;: {
      &quot;url-path-and-query&quot;: &quot;{{request.url}}&quot;,
      &quot;url-path&quot;: &quot;{{request.path}}&quot;,
      &quot;url-path-segments&quot;: &quot;{{request.pathSegments.[1]}}&quot;, // returns 'two' given '/one/two/three' path
      &quot;query&quot;: &quot;{{request.query.kind}}&quot;, // returns 'comics' given '/api/books?kind=comics'
      &quot;multi-query&quot;: &quot;{{request.query.kind.[1]}}&quot;, // returns 'novel' given '/api/books?kind=comics&amp;kind=novel'
      &quot;method&quot;: &quot;{{request.method}}&quot;, // http request method e.g. &quot;POST&quot;
      &quot;header&quot;: &quot;{{request.headers.Content-Type}}&quot;, // returns request header with given key
      &quot;multi-header&quot;: &quot;{{request.headers.cache-control.[0]}}&quot;, // returns first value of &quot;cache-control&quot; values
      &quot;body&quot;: &quot;{{request.body}}&quot;, // returns raw request body
      &quot;from-request&quot;: &quot;{{jsonPath request.body '$.name'}}&quot;, // takes field 'name' from json request body
      &quot;now&quot;: &quot;{{now}}&quot;, // current datetime (UTC)
      &quot;now-fmt&quot;: &quot;{{now format='yyyy/MM/dd'}}&quot;, // with custom Java SimpleDateFormat
      &quot;now-fmt-epoch&quot;: &quot;{{now format='epoch'}}&quot;, // epoch in milliseconds
      &quot;now-fmt-unix&quot;: &quot;{{now format='unix'}}&quot;, // epoch in seconds
      &quot;now-positive-offset&quot;: &quot;{{now offset='3 days'}}&quot;, // human time positive offset
      &quot;now-negative-offset&quot;: &quot;{{now offset='-3 days'}}&quot;, // human time negative offset
      &quot;now-with-timezone&quot;: &quot;{{now timezone='Europe/Rome'}}&quot;,
      &quot;number-is-odd&quot;: &quot;{{isOdd 3}}&quot;, // or 'isEven'
      &quot;string-capitalized&quot;: &quot;{{capitalize mister}}&quot;, // or 'decapitalize'
      &quot;string-uppercase&quot;: &quot;{{upper mister}}&quot;, // or 'lower'
      &quot;number-stripes&quot;: &quot;{{stripes request.body 'if-even' 'if-odd'}}&quot;,
      &quot;string-trim&quot;: &quot;{{trim request.body}}&quot;, // removes leading &amp; trailing whitespaces
      &quot;size&quot;: &quot;{{size request.body}}&quot;, // string length or array length
      &quot;base64-encode&quot;: &quot;{{base64 request.body padding=false}}&quot;, // padding is optional and defaults to true
      &quot;base64-decode&quot;: &quot;{{base64 request.body decode=true}}&quot;,
      &quot;url-encode&quot;: &quot;{{urlEncode request.header.x-raw}}&quot;,
      &quot;url-decode&quot;: &quot;{{urlEncode request.header.x-encoded decode=true}}&quot;,
      // you can also use 'any*' helpers. They will produce a random value
      &quot;regex&quot;: &quot;{{anyRegex '[a-z]{4}'}}&quot;, // generate a random string matching regex
      &quot;string&quot;: &quot;{{anyNonEmptyString}}&quot;, // or '{{anyNonEmptyString}}'
      &quot;alphanum&quot;: &quot;{{anyAlphaNumeric}}&quot;,
      &quot;boolean&quot;: &quot;{{anyBoolean}}&quot;,
      &quot;uuid&quot;: &quot;{{anyUuid}}&quot;,
      &quot;ip&quot;: &quot;{{anyIpAddress}}&quot;, // e.g. '127.0.0.1'
      &quot;host&quot;: &quot;{{anyHostname}}&quot;, // e.g. 'https://github.com'
      &quot;email&quot;: &quot;{{anyEmail}}&quot;, // e.g. 'john.doe@gmail.com'
      &quot;enum&quot;: &quot;{{anyOf 'alpha' 'beta' 'gamma'}}&quot;, // returns randomly one of those 3 values
      &quot;number&quot;: &quot;{{anyNumber}}&quot;, // integer or float 
      &quot;integer&quot;: &quot;{{anyI32}}&quot;, // also all Rust int types (u32, u8, i64 etc..)
      &quot;float&quot;: &quot;{{anyFloat}}&quot;,
      &quot;anyDate&quot;: &quot;{{anyDate}}&quot; // or 'anyTime', 'anyDatetime', 'anyIso8601'
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="request"><a class="header" href="#request">Request</a></h1>
<p>With request matching you have to describe all the conditions the incoming http requests have to match in order for your
stub response to be served. Most of the time, you will opt in for a conservative approach where you will have exhaustive
and strict conditions. That's when you want to assess the http caller behaves the right way. Other times you do not care
about request matching at all e.g. you use stubr to benchmark a reverse proxy: in that
case <code>request { &quot;method&quot;: &quot;ANY&quot; }</code> is enough. <strong>Just write the request matching you need</strong>.</p>
<h2 id="method"><a class="header" href="#method">Method</a></h2>
<p>Expects the request method. Use <code>ANY</code> when you do not care which method it will be.<br />
Available verbs are <code>GET</code>, <code>HEAD</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>CONNECT</code>, <code>OPTIONS</code>, <code>TRACE</code>, <code>PATCH</code></p>
<p><em>Note: <code>method</code> is optional and defaults to <code>ANY</code></em></p>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;method&quot;: &quot;GET&quot;
  }
}
</code></pre>
<h2 id="uri"><a class="header" href="#uri">URI</a></h2>
<p>To match request's URI (and maybe its query parameters). Only one of the following matcher is allowed. If more than one
are present, it does not fail but chooses one matcher according to the descending
priority <code>url</code> &gt; <code>urlPath</code> &gt; <code>urlPattern</code> &gt; <code>urlPathPattern</code></p>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;url&quot;: &quot;/api/uri?age=young&quot;,
    &quot;urlPath&quot;: &quot;/api/exact-uri&quot;,
    &quot;urlPattern&quot;: &quot;/api/regex-uri/([a-z]{4})\\?and=([a-z]{4})&quot;,
    &quot;urlPathPattern&quot;: &quot;/api/regex-uri/([a-z]{4})&quot;
  }
}
</code></pre>
<ul>
<li><code>url</code>: Matches by equality the URI and query parameters.</li>
<li><code>urlPath</code>: Matches by equality <strong>just</strong> the URI without query parameters.</li>
<li><code>urlPattern</code>: Matches URI and query parameters. Path segments and query parameters value can contain regexes.</li>
<li><code>urlPathPattern</code>: Matches <strong>just</strong> the URI without query parameters. Path segments can contain regexes.</li>
</ul>
<h2 id="query-parameters"><a class="header" href="#query-parameters">Query parameters</a></h2>
<p>Allows matching query parameters. Prefer this instead of <a href="stubs/request.html#uri">URI</a> matching just because it is clearer. Multivalued
query parameters are not supported yet.</p>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;queryParameters&quot;: {
      &quot;firstname&quot;: { &quot;equalTo&quot;: &quot;beltram&quot; },
      &quot;lastname&quot;: { &quot;equalTo&quot;: &quot;maldant&quot;, &quot;caseInsensitive&quot;: true },
      &quot;age&quot;: { &quot;absent&quot;: true },
      &quot;birthdate&quot;: { &quot;absent&quot;: false },
      &quot;city&quot;: { &quot;contains&quot;: &quot;at&quot; },
      &quot;title&quot;: { &quot;matches&quot;: &quot;([A-Za-z]+)&quot; },
      &quot;job&quot;: { &quot;doesNotMatch&quot;: &quot;([A-Za-z]+)&quot; }
    }
  }
}
</code></pre>
<ul>
<li><code>equalTo</code> by equality matcher. Can be a string, a boolean, a number, null etc... Can be turned case-insensitive
with <code>caseInsensitive</code>.</li>
<li><code>absent</code> specified query parameter key must be absent/present.</li>
<li><code>contains</code> value must contain the supplied string in a case-insensitive way</li>
<li><code>matches</code>/<code>doesNotMatch</code> value must match the supplied regex (or not)</li>
</ul>
<h2 id="headers"><a class="header" href="#headers">Headers</a></h2>
<p>Header matcher are <strong>exactly</strong> the same as <a href="stubs/request.html#query-parameters">query parameter matcher</a> above.</p>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;headers&quot;: {
      &quot;content-type&quot;: { &quot;equalTo&quot;: &quot;application/json&quot; }
    }
  }
}
</code></pre>
<h2 id="authorization"><a class="header" href="#authorization">Authorization</a></h2>
<p>Those matcher are exclusive to stubr and not available in Wiremock. They allow crafting more relaxed request matchers
when it comes to authorization. You could for example have stubs specialized for a specific user (we sometimes persona).</p>
<p>You can have matchers for Basic authentication (<a href="https://datatracker.ietf.org/doc/html/rfc7617">RFC 7617</a>). For example,
for matching <code>Authorization: Basic am9obi5kb2U6Y2hhbmdlbWU=</code> you would have:</p>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;basicAuth&quot;: {
      &quot;username&quot;: &quot;john.doe&quot;,
      &quot;password&quot;: &quot;changeme&quot;
    }
  }
}
</code></pre>
<p>You can also match a JWT token in the <code>Authorization</code> header as
per <a href="https://datatracker.ietf.org/doc/html/rfc7519">RFC 7519</a></p>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;jwtAuth&quot;: {
      &quot;equalTo&quot;: &quot;eyJhbGciOiJSUzI1NiJ9.e30.MBkQ...&quot;,
      &quot;alg&quot;: {
        &quot;equalTo&quot;: &quot;RS256&quot;,
        &quot;oneOf&quot;: [ &quot;RS256&quot;, &quot;HS256&quot; ]
      },
      &quot;payloadPatterns&quot;: [
        { &quot;equalToJson&quot;: { &quot;iss&quot;: &quot;john.doe&quot; } },
        { &quot;equalToJson&quot;: { &quot;exp&quot;: 1300819380 } },
        {
          &quot;expression&quot;: &quot;$.address&quot;,
          &quot;equalToJson&quot;: { &quot;street&quot;: &quot;rue de Rivoli&quot;, &quot;city&quot;: &quot;Paris&quot; }
        }
      ]
    }
  }
}
</code></pre>
<ul>
<li><code>equalTo</code> by equality matcher. Equivalent to <code>&quot;headers&quot;:{&quot;authorization&quot;:{&quot;equalTo&quot;: &quot;...&quot;}}</code>. If you have this
matcher, all the other ones will be ignored</li>
<li><code>alg.equalTo</code> by equality matcher. JWT algorithm has to be exactly this</li>
<li><code>alg.oneOf</code> JWT algorithm has to be one of the supplied values. Here are all the supported JWT
algorithms [<code>HS256</code>, <code>HS384</code>, <code>HS512</code>, <code>ES256</code>, <code>ES384</code>, <code>RS256</code>, <code>RS384</code>, <code>RS512</code>, <code>PS256</code>, <code>PS384</code>, <code>PS512</code>, <code>EdDSA</code>]</li>
<li><code>payloadPatterns</code> for matching the JWT body. Exactly the same matcher as <a href="stubs/request.html#body">body</a> ones.</li>
</ul>
<h2 id="body"><a class="header" href="#body">Body</a></h2>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;bodyPatterns&quot;: [
      { &quot;equalToJson&quot;: { &quot;name&quot;: &quot;bob&quot; } },
      {
        &quot;equalToJson&quot;: {&quot;names&quot;: [&quot;alice&quot;, &quot;bob&quot;]},
        &quot;ignoreExtraElements&quot;: true,
        &quot;ignoreArrayOrder&quot;: true
      },
      { &quot;matchesJsonPath&quot;: &quot;$.name&quot; },
      { &quot;matchesJsonPath&quot;: &quot;$.consoles[?(@.name == 'xbox')]&quot; },
      { &quot;matchesJsonPath&quot;: &quot;$.consoles[?(@.price &gt; 200)]&quot; },
      { &quot;expression&quot;: &quot;$.name&quot;, &quot;contains&quot;: &quot;at&quot; },
      { &quot;expression&quot;: &quot;$.user&quot;, &quot;equalToJson&quot;: { &quot;name&quot;: &quot;bob&quot; } },
      { &quot;expression&quot;: &quot;$.age&quot;, &quot;equalToJson&quot;: 42 },
      { &quot;binaryEqualTo&quot;: &quot;AQID&quot; }
    ]
  }
}
</code></pre>
<ul>
<li><code>equalToJson</code> strict equality matcher. Request body has to be exactly equal to this. If it is not used
with <code>expression</code>, all other matchers will be ignored. However, it can be relaxed with:
<ul>
<li><code>ignoreExtraElements</code> to ignore json fields in the http request not present in the matcher</li>
<li><code>ignoreArrayOrder</code> to match json arrays regardless the order of their items</li>
</ul>
</li>
<li><code>expression</code> a <a href="https://www.ietf.org/archive/id/draft-goessner-dispatch-jsonpath-00.html">JSONPath</a> matcher used to
narrow the matching. The matched expression has then to be verified by either:
<ul>
<li><code>equalToJson</code> for strict equality (can be another json object, a string, number etc..)</li>
<li><code>contains</code> ; if json matched by <code>expression</code> is a string it must contain the supplied string</li>
</ul>
</li>
<li><code>matchesJsonPath</code> json request body has to contain the supplied key identified by
a <a href="https://www.ietf.org/archive/id/draft-goessner-dispatch-jsonpath-00.html">JSONPath</a>. You can also
use <a href="https://docs.hevodata.com/sources/streaming/rest-api/writing-jsonpath-expressions/">JSONPath expression</a> to also
filter and match the json values</li>
<li><code>binaryEqualTo</code> byte equality matcher. Has to be base 64 encoded</li>
</ul>
<h2 id="priority"><a class="header" href="#priority">Priority</a></h2>
<p>Sometimes, you can have 2 different stubs that could both match a given http request. This happens most of the time when
you start writing stubs for your application errors. You basically should have:</p>
<ul>
<li>one relaxed stub for your nominal case matching for example <code>&quot;urlPathPattern&quot;: &quot;/users/([0-9]{4})&quot;</code></li>
<li>one stub for each error with hardcoded value e.g. <code>&quot;urlPath&quot;: &quot;/users/1234&quot;</code> for a <code>404</code> response</li>
</ul>
<p>The issue here is that if your stub server receives a <code>GET /users/1234</code> request, both stubs will match. You want your
error stub to have a higher than the nominal e.g. error stub will have a priority of 1 whereas the nominal one will have
a priority of 2.</p>
<pre><code class="language-json">{
  &quot;priority&quot;: 1
}
</code></pre>
<ul>
<li><code>priority</code> a u8. 1 is the highest priority, 255 the lowest, 5 the default value when absent. It is optional.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="response"><a class="header" href="#response">Response</a></h1>
<p>In the response part, you have to define the actual http response the stub server will serve when the stub matches the
incoming http request as we defined it with <a href="stubs/../stubs/request.html">request matching</a></p>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<p>The http response status. In the range <code>[100..599]</code>.</p>
<pre><code class="language-json">{
  &quot;response&quot;: {
    &quot;status&quot;: 200
  }
}
</code></pre>
<h2 id="header"><a class="header" href="#header">Header</a></h2>
<p>Http response headers. Note that keys are case-insensitive. Multivalued headers are not supported yet. You can
use <a href="stubs/response.html#response-templating">response templating</a> here as well if you add <code>&quot;transformers&quot;: [&quot;response-template&quot;]</code>.</p>
<pre><code class="language-json">{
  &quot;response&quot;: {
    &quot;transformers&quot;: [
      &quot;response-template&quot;
    ],
    &quot;headers&quot;: {
      &quot;content-type&quot;: &quot;application/json&quot;,
      &quot;ETag&quot;: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;,
      &quot;location&quot;: &quot;{{request.url}}/1234&quot;
    }
  }
}
</code></pre>
<h2 id="body-1"><a class="header" href="#body-1">Body</a></h2>
<p>There are different ways to define a http response. We'll just focus here on supplying hardcoded values in the response,
but you can relax all those fields with templates. We'll see that immediately in the next chapter.</p>
<pre><code class="language-json">{
  &quot;response&quot;: {
    &quot;body&quot;: &quot;Hello World !&quot;,
    &quot;base64Body&quot;: &quot;AQID&quot;,
    &quot;bodyFileName&quot;: &quot;tests/stubs/response.json&quot;,
    &quot;jsonBody&quot;: {
      &quot;name&quot;: &quot;john&quot;,
      &quot;surnames&quot;: [
        &quot;jdoe&quot;,
        &quot;johnny&quot;
      ]
    }
  }
}
</code></pre>
<ul>
<li><code>body</code> use this one if you have a text body or anything simple. If the body is large you'd better opt
for <code>bodyFileName</code>.</li>
<li><code>base64Body</code> if the body is not utf-8 encoded use it to supply a body as byte. Those have to be base 64 encoded.</li>
<li><code>bodyFileName</code> when the response gets large or to factorize some very common bodies, it is sometimes preferable to
extract it in a file. When using it in a Rust project, the file path is relative to the workspace root.</li>
<li><code>jsonBody</code> when the body is json. Even though such a body can be defined with all the previous fields, it is more
convenient to define a json response body here.</li>
</ul>
<h2 id="relaxed-field"><a class="header" href="#relaxed-field">Relaxed field</a></h2>
<p>Using only hardcoded values is a good way to start mocking things. But as time goes on, your project might start to get
bloated with a lot of stubs. You will also see the limit of hardcoded values when
doing <a href="stubs/../contract/index.html">contract testing</a>.</p>
<p>In order to &quot;relax&quot; your stub, you will have to use <a href="https://handlebarsjs.com/">Handlebars</a> helpers. They will allow you
to have random values generated for you, because, most of the time, that's what the actual application does. And, as a
consumer, you also don't care about the actual value of this field in your test i.e. <code>&quot;age&quot;: &quot;{{anyU8}}&quot;</code> will work in
all your unit tests because none of your unit tests expects a particular value for this field.</p>
<p>In order to use a Handlebars helper, you need to add <code>&quot;transformers&quot;: [&quot;response-template&quot;]</code>.</p>
<p>Keep in mind that such helper will also be used to generate assertions when you will be using this stub
for <a href="stubs/../contract/index.html">contract testing</a> while <a href="stubs/../contract/producer.html">verifying your producer</a>.</p>
<p>NB: those templates are not available in <a href="https://github.com/tomakehurst/wiremock">Wiremock</a>, you can only use them in stubr.</p>
<pre><code class="language-json">{
  &quot;response&quot;: {
    &quot;transformers&quot;: [
      &quot;response-template&quot;
    ],
    &quot;jsonBody&quot;: {
      &quot;regex&quot;: &quot;{{anyRegex '[a-z]{4}'}}&quot;,
      &quot;string&quot;: &quot;{{anyNonEmptyString}}&quot;,
      &quot;alphanum&quot;: &quot;{{anyAlphaNumeric}}&quot;,
      &quot;boolean&quot;: &quot;{{anyBoolean}}&quot;,
      &quot;uuid&quot;: &quot;{{anyUuid}}&quot;,
      &quot;ip&quot;: &quot;{{anyIpAddress}}&quot;,
      &quot;host&quot;: &quot;{{anyHostname}}&quot;,
      &quot;email&quot;: &quot;{{anyEmail}}&quot;,
      &quot;enum&quot;: &quot;{{anyOf 'alpha' 'beta' 'gamma'}}&quot;,
      &quot;number&quot;: &quot;{{anyNumber}}&quot;,
      &quot;integer&quot;: &quot;{{anyI32}}&quot;,
      &quot;float&quot;: &quot;{{anyFloat}}&quot;,
      &quot;anyDate&quot;: &quot;{{anyDate}}&quot;
    }
  }
}
</code></pre>
<ul>
<li><code>anyRegex</code> generates a value matching this regex. Tip: most of the time will be used for strings but if this regex
defines an integer, a float or a boolean and is used in <code>&quot;jsonBody&quot;&quot;</code> the generated value will be cast</li>
<li><code>anyNonEmptyString</code> or <code>anyNonBlankString</code> generates an arbitrary utf-8 string</li>
<li><code>anyAlphaNumeric</code> generates an arbitrary string with only alphanumeric characters</li>
<li><code>anyBoolean</code> generates either <code>true</code> or <code>false</code></li>
<li><code>anyUuid</code> generates a random UUIDv4</li>
<li><code>anyIpAddress</code> generates a random IP address e.g. <code>127.0.0.1</code></li>
<li><code>anyHostname</code> generates an arbitrary hostname e.g. <code>https://github.com</code></li>
<li><code>anyEmail</code> generates a random valid email address e.g. <code>john.doe@gmail.com</code></li>
<li><code>anyOf</code> given the supplied values, will pick one randomly. Only works for strings.</li>
<li><code>anyNumber</code> when one does not care about the number size, generates either an integer or a float</li>
<li><code>anyI32</code> or <code>anyU32</code> etc.. generates a random integer. Possible values
are [<code>anyU64</code>, <code>anyI64</code>, <code>anyU32</code>, <code>anyI32</code>, <code>anyU16</code>, <code>anyI16</code>, <code>anyU8</code>, <code>anyI8</code>]</li>
<li><code>anyFloat</code> generates a random float</li>
<li><code>anyDate</code> generates a date with format <code>yyyy-mm-dd</code></li>
<li><code>anyTime</code> generates a time with format <code>hh:mm:ss</code></li>
<li><code>anyDatetime</code> generates a datetime with format <code>yyyy-mm-ddThh:mm:ss</code></li>
<li><code>anyIso8601</code> generates an <a href="https://en.wikipedia.org/wiki/ISO_8601">iso-8601</a> compliant datetime</li>
</ul>
<h2 id="response-templating"><a class="header" href="#response-templating">Response templating</a></h2>
<p>Another kind of relaxing you can do is by being able to represent as best as possible the actual http response of your
app. Very often, a field in the response is the exact same as the one in the request e.g. in a POST request to create
a REST resource. You can use in your response parts of the request to do so.</p>
<pre><code class="language-json">{
  &quot;response&quot;: {
    &quot;transformers&quot;: [
      &quot;response-template&quot;
    ],
    &quot;jsonBody&quot;: {
      &quot;url-path-and-query&quot;: &quot;{{request.url}}&quot;,
      &quot;url-path&quot;: &quot;{{request.path}}&quot;,
      &quot;url-path-segments&quot;: &quot;{{request.pathSegments.[1]}}&quot;,
      &quot;query&quot;: &quot;{{request.query.kind}}&quot;,
      &quot;multi-query&quot;: &quot;{{request.query.kind.[1]}}&quot;,
      &quot;method&quot;: &quot;{{request.method}}&quot;,
      &quot;header&quot;: &quot;{{request.headers.Content-Type}}&quot;,
      &quot;multi-header&quot;: &quot;{{request.headers.cache-control.[0]}}&quot;,
      &quot;body&quot;: &quot;{{request.body}}&quot;,
      &quot;from-request&quot;: &quot;{{jsonPath request.body '$.name'}}&quot;
    }
  }
}
</code></pre>
<ul>
<li><code>request.url</code> given a request to <code>http://localhost/api/path?a=b</code> returns <code>path?a=b</code></li>
<li><code>request.path</code> given a request to <code>http://localhost/api/path?a=b</code> returns <code>api/path</code></li>
<li><code>request.pathSegments.[i]</code> allows picking a part of the url path (<code>i</code> is zero indexed) e.g.
<code>http://localhost/a/b/c</code> with <code>i</code> == 1 returns <code>b</code></li>
<li><code>query.&lt;selector&gt;.[i]</code> allows picking a named query parameter. Replace <code>&lt;selector&gt;</code> by the name of the query
parameter. If the query parameter is multivalued, you can select only one with the zero indexed <code>i</code>. For example with
<code>http://localhost?a=1&amp;a=2&amp;a=3&amp;b=1</code> then <code>{{query.b}}</code> returns <code>1</code> and <code>{{query.a.[1]}}</code> returns <code>2</code></li>
<li><code>request.method</code> returns the (uppercase) http request method. If you want the lowercase method just <code>{{lower request.method}}</code></li>
<li><code>request.headers.&lt;selector&gt;.[i]</code> about the same as picking query parameters. Note that here <code>selector</code> is case-insensitive.</li>
<li><code>request.body</code> takes the raw request body without altering it</li>
<li><code>jsonPath request.body '&lt;json-path&gt;'</code> for templating only a field from request's json body. <code>json-path</code> is the JSONPath 
for selecting the right field. Use an <a href="https://jsonpath.com/">online JSONPath evaluator</a> to try out your paths.</li>
</ul>
<p>You also sometimes have to generate dynamic data or to transform existing one:</p>
<pre><code class="language-json">{
  &quot;response&quot;: {
    &quot;transformers&quot;: [
      &quot;response-template&quot;
    ],
    &quot;jsonBody&quot;: {
      &quot;now&quot;: &quot;{{now}}&quot;,
      &quot;now-fmt&quot;: &quot;{{now format='yyyy/MM/dd'}}&quot;,
      &quot;now-fmt-epoch&quot;: &quot;{{now format='epoch'}}&quot;,
      &quot;now-fmt-unix&quot;: &quot;{{now format='unix'}}&quot;,
      &quot;now-positive-offset&quot;: &quot;{{now offset='3 days'}}&quot;,
      &quot;now-negative-offset&quot;: &quot;{{now offset='-3 days'}}&quot;,
      &quot;now-with-timezone&quot;: &quot;{{now timezone='Europe/Rome'}}&quot;,
      &quot;number-is-odd&quot;: &quot;{{isOdd request.body}}&quot;,
      &quot;number-stripes&quot;: &quot;{{stripes request.body 'if-even' 'if-odd'}}&quot;,
      &quot;string-capitalized&quot;: &quot;{{capitalize request.body}}&quot;,
      &quot;string-uppercase&quot;: &quot;{{upper request.body}}&quot;,
      &quot;string-trim&quot;: &quot;{{trim request.body}}&quot;,
      &quot;size&quot;: &quot;{{size request.body}}&quot;,
      &quot;base64-encode&quot;: &quot;{{base64 request.body padding=false}}&quot;,
      &quot;base64-decode&quot;: &quot;{{base64 request.body decode=true}}&quot;,
      &quot;url-encode&quot;: &quot;{{urlEncode request.header.x-raw}}&quot;,
      &quot;url-decode&quot;: &quot;{{urlEncode request.header.x-encoded decode=true}}&quot;
    }
  }
}
</code></pre>
<ul>
<li><code>now</code> by default return the current datetime in <a href="https://www.rfc-editor.org/rfc/rfc3339">RFC 3339</a> format (this is only for backward compatibility with Wiremock)
<ul>
<li><code>format</code> could be either:
<ul>
<li>a custom <a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html">Java SimpleDateFormat</a> (for Wiremock compatibility) e.g. <code>format='yyyy/MM/dd'</code></li>
<li><code>epoch</code> Unix timestamp in milliseconds</li>
<li><code>unix</code> Unix timestamp in seconds</li>
</ul>
</li>
<li><code>offset</code> now with the given offset expressed in human-readable format. Refer to <a href="https://docs.rs/humantime/latest/humantime/fn.parse_duration.html">humantime documentation</a> for further examples.</li>
<li><code>timezone</code> for using a string timezone (see <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List">list</a>)</li>
</ul>
</li>
<li><code>isOdd</code> or <code>isEven</code> returns a boolean whether the numeric value is an even or odd integer</li>
<li><code>capitalize</code> first letter to uppercase e.g. <code>mister</code> becomes <code>Mister</code></li>
<li><code>upper</code> or <code>lower</code> recapitalizes the whole word</li>
<li><code>stripes</code> returns alternate values depending if the tested value is even or odd</li>
<li><code>trim</code> removes leading &amp; trailing whitespaces</li>
<li><code>size</code> returns the number of bytes for a string (⚠️ not the number of characters) or the size of an array</li>
<li><code>base64</code> for standard (no base64 url encoding yet) Base64 encoding
<ul>
<li><code>decode</code> for decoding when true</li>
<li><code>padding</code> with/without padding</li>
</ul>
</li>
<li><code>urlEncode</code> for url encoding the value. Use <code>decode=true</code> to decode</li>
</ul>
<h2 id="delay"><a class="header" href="#delay">Delay</a></h2>
<p>You can also use stubr to simulate http server runtime behaviour. And most of the time you'll want to introduce latencies
to check how your consuming application reacts to such delays. Currently, the options are quite sparse but should grow !</p>
<pre><code class="language-json">{
  &quot;response&quot;: {
    &quot;fixedDelayMilliseconds&quot;: 2000
  }
}
</code></pre>
<ul>
<li><code>fixedDelayMilliseconds</code> a delay (in milliseconds) added everytime this stub is matched. If you are using stubr 
standalone through the <a href="stubs/../cli.html">cli</a>, this value can be either superseded by <code>--delay</code> or complemented by <code>--latency</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relaxing-a-stub"><a class="header" href="#relaxing-a-stub">Relaxing a stub</a></h1>
<h2 id="request-matching"><a class="header" href="#request-matching">Request matching</a></h2>
<h2 id="response-1"><a class="header" href="#response-1">Response</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording"><a class="header" href="#recording">Recording</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording-your-actix-app"><a class="header" href="#recording-your-actix-app">Recording your actix app</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording-with-the-cli"><a class="header" href="#recording-with-the-cli">Recording with the cli</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording-your-isahc-calls"><a class="header" href="#recording-your-isahc-calls">Recording your isahc calls</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording-your-reqwest-calls"><a class="header" href="#recording-your-reqwest-calls">Recording your reqwest calls</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording-standalone"><a class="header" href="#recording-standalone">Recording standalone</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli"><a class="header" href="#cli">Cli</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker"><a class="header" href="#docker">Docker</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ide-completion"><a class="header" href="#ide-completion">IDE completion</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
