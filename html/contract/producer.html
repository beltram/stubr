<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>As a producer - stubr</title>
        <!-- Custom HTML head -->
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../getting-started/unit-test.html"><strong aria-hidden="true">2.</strong> Getting started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-started/unit-test.html"><strong aria-hidden="true">2.1.</strong> unit test</a></li><li class="chapter-item expanded "><a href="../getting-started/standalone.html"><strong aria-hidden="true">2.2.</strong> standalone</a></li></ol></li><li class="chapter-item expanded "><a href="../contract/index.html"><strong aria-hidden="true">3.</strong> Contract Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../contract/producer.html" class="active"><strong aria-hidden="true">3.1.</strong> As a producer</a></li><li class="chapter-item expanded "><a href="../contract/consumer.html"><strong aria-hidden="true">3.2.</strong> As a consumer</a></li><li class="chapter-item expanded "><a href="../contract/relaxing.html"><strong aria-hidden="true">3.3.</strong> Relaxing</a></li></ol></li><li class="chapter-item expanded "><a href="../stubs/index.html"><strong aria-hidden="true">4.</strong> Writing Stubs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../stubs/request.html"><strong aria-hidden="true">4.1.</strong> Request</a></li><li class="chapter-item expanded "><a href="../stubs/response.html"><strong aria-hidden="true">4.2.</strong> Response</a></li></ol></li><li class="chapter-item expanded "><a href="../recording/index.html"><strong aria-hidden="true">5.</strong> Recording</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../recording/actix.html"><strong aria-hidden="true">5.1.</strong> Actix</a></li><li class="chapter-item expanded "><a href="../recording/cli.html"><strong aria-hidden="true">5.2.</strong> Cli</a></li><li class="chapter-item expanded "><a href="../recording/isahc.html"><strong aria-hidden="true">5.3.</strong> isahc</a></li><li class="chapter-item expanded "><a href="../recording/reqwest.html"><strong aria-hidden="true">5.4.</strong> reqwest</a></li><li class="chapter-item expanded "><a href="../recording/standalone.html"><strong aria-hidden="true">5.5.</strong> standalone</a></li></ol></li><li class="chapter-item expanded "><a href="../cli.html"><strong aria-hidden="true">6.</strong> Cli</a></li><li class="chapter-item expanded "><a href="../docker.html"><strong aria-hidden="true">7.</strong> Docker</a></li><li class="chapter-item expanded "><a href="../benchmark.html"><strong aria-hidden="true">8.</strong> Benchmark</a></li><li class="chapter-item expanded "><a href="../ide-completion.html"><strong aria-hidden="true">9.</strong> IDE completion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">stubr</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="as-a-producer"><a class="header" href="#as-a-producer">As a producer</a></h1>
<p>We'll use actix in those examples because it is the only web framework currently supported for verifying the producer,
others will come ! And of course it does not impact the consumer where you can use any technology you want since <a href="https://github.com/beltram/stubr">stubr</a>
can be used <a href="../getting-started/standalone.html">standalone</a> (you can even use a language other than Rust !).</p>
<h2 id="endpoint"><a class="header" href="#endpoint">endpoint</a></h2>
<p>We'll begin in a very common situation where your producer exposes a http endpoint. We will make the endpoint as simple
and stupid as possible with a flat <code>Beer</code> resource and an in-memory database. We'll just expose an endpoint for creating
and fetching a resource which should cover most of the use cases.</p>
<pre><code class="language-rust ignore noplayground edition2021">use actix_web::http::header::ContentType;
use actix_web::web;

// simple in-memory database
pub type Database = std::sync::RwLock&lt;std::collections::HashMap&lt;u32, Beer&gt;&gt;;

#[actix_web::post(&quot;/beers&quot;)]
pub async fn create(mut beer: web::Json&lt;Beer&gt;, db: web::Data&lt;Database&gt;) -&gt; impl actix_web::Responder {
    let exists = db.read().unwrap().iter().any(|(_, b)| &amp;beer.0 == b);
    if !exists {
        let next_id = db.read().unwrap().len() as u32;
        beer.id = Some(next_id);
        db.write().unwrap().insert(next_id, beer.clone());
        actix_web::HttpResponse::Created()
            .content_type(ContentType::json())
            .body(serde_json::to_string(&amp;beer).unwrap())
    } else {
        actix_web::HttpResponse::Conflict()
            .content_type(ContentType::json())
            .body(serde_json::json!({&quot;message&quot;: &quot;Beer already exists&quot;}).to_string())
    }
}

#[actix_web::get(&quot;/beers/{id}&quot;)]
pub async fn find_by_id(path: web::Path&lt;u32&gt;, db: web::Data&lt;Database&gt;) -&gt; impl actix_web::Responder {
    let id = path.into_inner();
    if let Some(beer) = db.read().unwrap().get(&amp;id) {
        actix_web::HttpResponse::Ok()
            .content_type(ContentType::json())
            .body(serde_json::to_string(beer).unwrap())
    } else {
        actix_web::HttpResponse::NotFound()
            .content_type(ContentType::json())
            .body(serde_json::json!({&quot;message&quot;: &quot;Beer not found&quot;}).to_string())
    }
}

#[derive(Debug, Clone, Eq, serde::Serialize, serde::Deserialize)]
pub struct Beer {
    pub id: Option&lt;u32&gt;,
    pub name: String,
    pub price: u32,
}

impl PartialEq for Beer {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.name == other.name
    }
}</code></pre>
<h2 id="tests"><a class="header" href="#tests">tests</a></h2>
<p>Then as we do things seriously, we will write some tests. For the <code>create</code> endpoint we'll have a nominal case where the 
beer we create succeeds and another negative one where it fails because we have a uniqueness constraint on the Beer's 
<code>name</code> and <code>price</code> fields. For the <code>find_by_id</code> one, we'll have a nominal case and a <code>404 Not Found</code> one.</p>
<pre><code class="language-rust ignore noplayground edition2021">use actix_web::{
    test::{call_service, init_service, TestRequest},
    web, App,
};
use asserhttp::*;

use actix_producer::api::beer::*;

mod find_by_id {
    use super::*;

    #[actix_web::test]
    async fn find_by_id_should_find_one() {
        let app = App::new()
            .app_data(sample_db())
            .service(find_by_id)
            .wrap(stubr::ActixRecord::default()); // ðŸ‘ˆ record
        let beers = sample();
        let (id, to_find) = beers.get(0).unwrap();
        let req = TestRequest::get().uri(&amp;format!(&quot;/beers/{}&quot;, id)).to_request();
        call_service(&amp;init_service(app).await, req)
            .await
            .expect_status_ok()
            .expect_content_type_json()
            .expect_body_json(|b: Beer| assert_eq!(&amp;b, to_find));
    }

    #[actix_web::test]
    async fn find_by_id_should_not_find_any() {
        let app = App::new()
            .app_data(sample_db())
            .service(find_by_id)
            .wrap(stubr::ActixRecord::default()); // ðŸ‘ˆ record
        let req = TestRequest::get().uri(&quot;/beers/999&quot;).to_request();
        call_service(&amp;init_service(app).await, req).await.expect_status_not_found();
    }
}

mod create {
    use super::*;

    #[actix_web::test]
    async fn create_should_create_one() {
        let beer = Beer {
            id: None,
            name: &quot;Heineken&quot;.to_string(),
            price: 4,
        };
        let app = App::new()
            .app_data(empty_db())
            .service(create)
            .wrap(stubr::ActixRecord::default()); // ðŸ‘ˆ record
        let req = TestRequest::post().uri(&quot;/beers&quot;).set_json(beer.clone()).to_request();
        call_service(&amp;init_service(app).await, req)
            .await
            .expect_status_created()
            .expect_content_type_json()
            .expect_body_json(|b: Beer| {
                assert!(b.id.is_some());
                assert_eq!(b.name, beer.name);
                assert_eq!(b.price, beer.price);
            });
    }

    #[actix_web::test]
    async fn create_should_conflict_when_already_exists_by_name() {
        let (_id, beer) = sample().get(0).unwrap().clone();
        let app = App::new()
            .app_data(sample_db())
            .service(create)
            .wrap(stubr::ActixRecord::default()); // ðŸ‘ˆ record
        let req = TestRequest::post().uri(&quot;/beers&quot;).set_json(beer.clone()).to_request();
        call_service(&amp;init_service(app).await, req).await.expect_status_conflict();
    }
}

pub fn sample_db() -&gt; web::Data&lt;Database&gt; {
    web::Data::new(std::sync::RwLock::new(sample().into()))
}

pub fn empty_db() -&gt; web::Data&lt;Database&gt; {
    web::Data::new(std::sync::RwLock::new([].into()))
}

pub fn sample() -&gt; [(u32, Beer); 2] {
    [
        (
            0,
            Beer {
                id: Some(0),
                name: &quot;Leffe&quot;.to_string(),
                price: 5,
            },
        ),
        (
            1,
            Beer {
                id: Some(1),
                name: &quot;1664&quot;.to_string(),
                price: 3,
            },
        ),
    ]
}</code></pre>
<h2 id="recording"><a class="header" href="#recording">recording</a></h2>
<p>Although it is optional, we'll use <a href="../recording/actix.html">recording</a> here to easily create one stub for each test. 
Recording is triggered by the <code>.wrap(stubr::ActixRecord::default())</code> line. Those recorded stubs will be in 
<code>target/stubs/localhost</code>. </p>
<h2 id="import-stubs"><a class="header" href="#import-stubs">import stubs</a></h2>
<p>In order for a producer to expose stubs, they have to live in a <code>stubs</code> folder in the root of your project. So 
copy/paste the 4 recorded stubs into this folder and arrange them a bit (remove recording noise) to match the following.</p>
<details>
<summary><b>create</b></summary>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;method&quot;: &quot;POST&quot;,
    &quot;urlPath&quot;: &quot;/beers&quot;,
    &quot;headers&quot;: {
      &quot;content-type&quot;: {
        &quot;equalTo&quot;: &quot;application/json&quot;
      }
    },
    &quot;bodyPatterns&quot;: [
      {
        &quot;equalToJson&quot;: {
          &quot;name&quot;: &quot;Heineken&quot;,
          &quot;price&quot;: 4
        }
      }
    ]
  },
  &quot;response&quot;: {
    &quot;status&quot;: 201,
    &quot;jsonBody&quot;: {
      &quot;id&quot;: 2,
      &quot;name&quot;: &quot;Heineken&quot;,
      &quot;price&quot;: 4
    },
    &quot;headers&quot;: {
      &quot;content-type&quot;: &quot;application/json&quot;
    }
  }
}
</code></pre>
</details>
<details>
<summary><b>create with name conflict</b></summary>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;method&quot;: &quot;POST&quot;,
    &quot;urlPath&quot;: &quot;/beers&quot;,
    &quot;headers&quot;: {
      &quot;content-type&quot;: {
        &quot;equalTo&quot;: &quot;application/json&quot;
      }
    },
    &quot;bodyPatterns&quot;: [
      {
        &quot;equalToJson&quot;: {
          &quot;name&quot;: &quot;Leffe&quot;,
          &quot;price&quot;: 5
        }
      }
    ]
  },
  &quot;response&quot;: {
    &quot;status&quot;: 409,
    &quot;jsonBody&quot;: {
      &quot;message&quot;: &quot;Beer already exists&quot;
    },
    &quot;headers&quot;: {
      &quot;content-type&quot;: &quot;application/json&quot;
    }
  }
}
</code></pre>
</details>
<details>
<summary><b>find by id</b></summary>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;method&quot;: &quot;GET&quot;,
    &quot;urlPath&quot;: &quot;/beers/0&quot;
  },
  &quot;response&quot;: {
    &quot;status&quot;: 200,
    &quot;jsonBody&quot;: {
      &quot;id&quot;: 0,
      &quot;name&quot;: &quot;Leffe&quot;,
      &quot;price&quot;: 5
    },
    &quot;headers&quot;: {
      &quot;content-type&quot;: &quot;application/json&quot;
    }
  }
}
</code></pre>
</details>
<details>
<summary><b>find by id not found</b></summary>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;method&quot;: &quot;GET&quot;,
    &quot;urlPath&quot;: &quot;/beers/404&quot;
  },
  &quot;response&quot;: {
    &quot;status&quot;: 404,
    &quot;jsonBody&quot;: {
      &quot;message&quot;: &quot;Beer not found&quot;
    },
    &quot;headers&quot;: {
      &quot;content-type&quot;: &quot;application/json&quot;
    }
  }
}
</code></pre>
</details>
<h2 id="verify"><a class="header" href="#verify">verify</a></h2>
<p>And finally, we have to verify that the stubs exposed by our producer match the actual implementation. To do so, <a href="https://github.com/beltram/stubr">stubr</a>
exports the <code>StubrVerify</code> trait with the <code>.verify()</code> method you have to invoke. There is no automatic verification of
stubs possible, it has to be explicit in a test. It is advised to declare it in a file with just the verification test.</p>
<p>Such a test will start by declaring your actix app with all the endpoints. In order to verify it, <a href="https://github.com/beltram/stubr">stubr</a> will create a
test for every stub in <code>./stubs</code> by converting, for each, the <code>request</code> part in an actual actix integration test.</p>
<p>But you might need some state ! For example, think of the <code>find by id</code> endpoint. It cannot be verified if your database
is empty. Likewise, stubs are verified in no particular order (since anyway your endpoint are most likely stateless, 
right ?). Executing some tests (for example a &quot;delete&quot; endpoint) might affect others. So before each test, we have to
reset our application state. You can do that with the <code>stubr::ActixVerifyLifecycle</code> middleware, for example here to
wipe our database then populate it with our sample data (it is recommended to reuse the same as in your tests).</p>
<p>Finally, call <code>.verify()</code> (a bit different in our example) to launch the verification test. If it passes, you have the
guarantee your stubs accurately represent your application API. </p>
<pre><code class="language-rust ignore noplayground edition2021">use crate::api::beer::*;
use actix_producer::api::beer::*;

#[actix_web::test]
async fn should_verify() {
    use stubr::StubrVerify as _;

    actix_web::App::new()
        .app_data(sample_db())
        .service(create)
        .service(find_by_id)
        // reset application state
        .wrap(stubr::ActixVerifyLifecycle::&lt;Database&gt;(|db| {
            let mut db = db.write().unwrap();
            db.clear();
            for (i, beer) in sample() {
                db.insert(i, beer);
            }
        }))
        // required because this sample lives in a project with other stubs.
        // Otherwise just use '.verify()'
        .verify_except(|stub_name: &amp;str| stub_name.starts_with(&quot;pet-&quot;))
        .await;
}</code></pre>
<p>Now let's use those stubs in a consumer.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../contract/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../contract/consumer.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../contract/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../contract/consumer.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script>
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>
        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>
    </body>
</html>
