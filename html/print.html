<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>stubr</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="getting-started/unit-test.html"><strong aria-hidden="true">2.</strong> Getting started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/unit-test.html"><strong aria-hidden="true">2.1.</strong> unit test</a></li><li class="chapter-item expanded "><a href="getting-started/standalone.html"><strong aria-hidden="true">2.2.</strong> standalone</a></li></ol></li><li class="chapter-item expanded "><a href="contract/index.html"><strong aria-hidden="true">3.</strong> Contract Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contract/producer.html"><strong aria-hidden="true">3.1.</strong> As a producer</a></li><li class="chapter-item expanded "><a href="contract/consumer.html"><strong aria-hidden="true">3.2.</strong> As a consumer</a></li><li class="chapter-item expanded "><a href="contract/relaxing.html"><strong aria-hidden="true">3.3.</strong> Relaxing</a></li></ol></li><li class="chapter-item expanded "><a href="stubs/index.html"><strong aria-hidden="true">4.</strong> Writing Stubs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="stubs/request.html"><strong aria-hidden="true">4.1.</strong> Request</a></li><li class="chapter-item expanded "><a href="stubs/response.html"><strong aria-hidden="true">4.2.</strong> Response</a></li></ol></li><li class="chapter-item expanded "><a href="recording/index.html"><strong aria-hidden="true">5.</strong> Recording</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="recording/actix.html"><strong aria-hidden="true">5.1.</strong> Actix</a></li><li class="chapter-item expanded "><a href="recording/cli.html"><strong aria-hidden="true">5.2.</strong> Cli</a></li><li class="chapter-item expanded "><a href="recording/isahc.html"><strong aria-hidden="true">5.3.</strong> isahc</a></li><li class="chapter-item expanded "><a href="recording/reqwest.html"><strong aria-hidden="true">5.4.</strong> reqwest</a></li><li class="chapter-item expanded "><a href="recording/standalone.html"><strong aria-hidden="true">5.5.</strong> standalone</a></li></ol></li><li class="chapter-item expanded "><a href="grpc.html"><strong aria-hidden="true">6.</strong> gRPC</a></li><li class="chapter-item expanded "><a href="cli.html"><strong aria-hidden="true">7.</strong> Cli</a></li><li class="chapter-item expanded "><a href="docker.html"><strong aria-hidden="true">8.</strong> Docker</a></li><li class="chapter-item expanded "><a href="benchmark.html"><strong aria-hidden="true">9.</strong> Benchmark</a></li><li class="chapter-item expanded "><a href="ide-completion.html"><strong aria-hidden="true">10.</strong> IDE completion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">stubr</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="stubr"><a class="header" href="#stubr">Stubr</a></h1>
<p><a href="https://github.com/beltram/stubr">Stubr</a> is a stubbing and contract testing tool. It supports the same API for writing
stubs as <a href="https://github.com/tomakehurst/wiremock">Wiremock</a>. You can also see it as an adaptation
of <a href="https://github.com/LukeMathWalker/wiremock-rs">wiremock-rs</a> with the ability to write stubs as json files instead of
code.</p>
<p>You might ask <strong>why would I want to do such a thing ?</strong> After all, code is a great way to write stubs. That's true ! But
it also comes with some limitations: <strong>it is hard to share.</strong> And it especially starts tickling your attention when you
try to do <a href="https://martinfowler.com/bliki/ContractTest.html">contract testing</a>. You have to share a <code>contract</code> between a
producer and a consumer. Sometimes, both are written in different languages, or with different frameworks ; and even
when that's not the case, they might both be sharing a different version of that wicked dependency which clash together.
Having your contract written in json has the benefits of being <strong>portable</strong>, <strong>lightweight</strong> and <strong>polyglot</strong> (if you
stick to a standard API such as Wiremock's one). So you could for example test a producer service written in Java and
vice versa !</p>
<p><a href="https://github.com/beltram/stubr">Stubr</a> aims at bridging multiple languages and framework and enable developers to
test their integration with remote application without having to mock their own code. It also enables them to shorten
their feedback loop: no need for a complex CI to make sure 2 application share the same API definition, everything can
be done offline.</p>
<p>Then, beyond <a href="contract/index.html">contract testing</a>, it tries to cover others areas:</p>
<ul>
<li><a href="getting-started/unit-test.html">stubbing</a> in your Rust project for simulating remote services your app depends on</li>
<li><a href="recording/index.html">recording</a> for capturing http traffic and turning it into a stub file</li>
<li><a href="getting-started/standalone.html">standalone</a> for running <a href="https://github.com/beltram/stubr">stubr</a> stub server from
anywhere and benefiting from Rust performances. Available as a <a href="cli.html">cli</a> or a <a href="docker.html">Docker image</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>You will of course want to use <a href="https://github.com/beltram/stubr">stubr</a> in your Rust project. We will cover here the case where you want to mock an external
http application you do not own (if you own it, you might be interested in <a href="getting-started/../contract/index.html">contract testing</a>).</p>
<p><strong>First you need a stub.</strong> A stub is a json file which represents the endpoint you want to mock. You have 2 options from
now on:</p>
<ul>
<li><a href="getting-started/../recording/index.html">Record</a> the existing application (if you are lazy)</li>
<li><a href="getting-started/../stubs/index.html">Write the json stub yourself</a> ðŸ¥µ</li>
</ul>
<p>We are going to be even lazier and simply create the json stub with a command.</p>
<p>You should have a project layout like this:</p>
<pre><code class="language-text">â”œâ”€â”€ src
â”‚   â”œâ”€â”€ lib.rs
â””â”€â”€ tests
    â”œâ”€â”€ stubs
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ README.md
</code></pre>
<p>We are going to create the stub under <code>tests/stubs/</code>, the default location. You can place them wherever you want of course,
but you'll see it's more convenient to place them here.</p>
<pre><code class="language-bash">echo &quot;{\&quot;request\&quot;: {\&quot;method\&quot;: \&quot;GET\&quot;, \&quot;urlPath\&quot;: \&quot;/hello\&quot;}, \&quot;response\&quot;: { \&quot;body\&quot;: \&quot;Hello stubr\&quot; }}&quot; &gt; tests/stubs/hello.json
</code></pre>
<p>And with a few lines of code we can spawn a mock server and call (here with reqwest for example).</p>
<pre><code class="language-rust ignore noplayground edition2021">use asserhttp::*;

#[tokio::test]
async fn getting_started() {
    // run a mock server with the stub ðŸ‘‡
    let stubr = stubr::Stubr::start(&quot;tests/stubs/hello.json&quot;).await;
    // or use 'start_blocking' for a non-async version

    // the mock server started on a random port e.g. '127.0.0.1:43125'
    // so we use the stub instance 'path' (or 'uri') method to get the address back
    let uri = stubr.path(&quot;/hello&quot;);
    reqwest::get(uri).await
        // (optional) use asserhttp for assertions
        .expect_status_ok()
        .expect_content_type_text()
        .expect_body_text_eq(&quot;Hello stubr&quot;);
}</code></pre>
<p>But we can further shorten this with a attribute macro: <code>#[stubr::mock]</code></p>
<pre><code class="language-rust ignore noplayground edition2021">use asserhttp::*;

#[tokio::test]
#[stubr::mock(&quot;hello.json&quot;)] // ðŸ‘ˆ this starts the mock server
async fn getting_started() {
    // a local binding 'stubr' has been created, equivalent to the one before
    let uri = stubr.path(&quot;/hello&quot;);
    reqwest::get(uri)
        .await
        .expect_status_ok()
        .expect_content_type_text()
        .expect_body_text_eq(&quot;Hello stubr&quot;);
}</code></pre>
<p>You can also use the macro in non-async test methods of course, the macro will adapt by itself.<br />
Note that here you can omit the <code>tests/stubs/</code> path prefix. If you placed your files in the default location, they are
going to be searched from there.<br />
As well, you can mount many stubs with the macro e.g. <code>#[stubr::mock(&quot;hello.json&quot;, &quot;goodbye.json&quot;)]</code>.
By default, if you take care to place only stubs with different request matching under <code>tests/stubs</code>, you can simply
place <code>#[stubr::mock]</code>. It will recursively mount all the stubs under <code>tests/stubs</code>, searching also in subdirectories.</p>
<p>Here are all the options you can use with the attribute macro</p>
<pre><code class="language-rust ignore noplayground edition2021">#[tokio::test]
#[stubr::mock(full_path = &quot;tests/book/hello.json&quot;, port = 1234, verify = true)]
async fn getting_started() {}</code></pre>
<ul>
<li><code>full_path</code>: use this if your stubs are not under <code>tests/stubs</code> but elsewhere. Note that it can point to a directory.</li>
<li><code>port</code> when you want an explicit port for your mock server</li>
<li><code>verify</code> to turn on verification of the number of times a stub gets called (<code>expect</code> field in your stubs). 
See <a href="getting-started/../stubs/response.html#simulate-fault">simulating fault</a> for reference</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-1"><a class="header" href="#getting-started-1">Getting started</a></h1>
<p>You will of course want to use <a href="https://github.com/beltram/stubr">stubr</a> in your Rust project. We will cover here the case where you want to mock an external
http application you do not own (if you own it, you might be interested in <a href="getting-started/../contract/index.html">contract testing</a>).</p>
<p><strong>First you need a stub.</strong> A stub is a json file which represents the endpoint you want to mock. You have 2 options from
now on:</p>
<ul>
<li><a href="getting-started/../recording/index.html">Record</a> the existing application (if you are lazy)</li>
<li><a href="getting-started/../stubs/index.html">Write the json stub yourself</a> ðŸ¥µ</li>
</ul>
<p>We are going to be even lazier and simply create the json stub with a command.</p>
<p>You should have a project layout like this:</p>
<pre><code class="language-text">â”œâ”€â”€ src
â”‚   â”œâ”€â”€ lib.rs
â””â”€â”€ tests
    â”œâ”€â”€ stubs
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ README.md
</code></pre>
<p>We are going to create the stub under <code>tests/stubs/</code>, the default location. You can place them wherever you want of course,
but you'll see it's more convenient to place them here.</p>
<pre><code class="language-bash">echo &quot;{\&quot;request\&quot;: {\&quot;method\&quot;: \&quot;GET\&quot;, \&quot;urlPath\&quot;: \&quot;/hello\&quot;}, \&quot;response\&quot;: { \&quot;body\&quot;: \&quot;Hello stubr\&quot; }}&quot; &gt; tests/stubs/hello.json
</code></pre>
<p>And with a few lines of code we can spawn a mock server and call (here with reqwest for example).</p>
<pre><code class="language-rust ignore noplayground edition2021">use asserhttp::*;

#[tokio::test]
async fn getting_started() {
    // run a mock server with the stub ðŸ‘‡
    let stubr = stubr::Stubr::start(&quot;tests/stubs/hello.json&quot;).await;
    // or use 'start_blocking' for a non-async version

    // the mock server started on a random port e.g. '127.0.0.1:43125'
    // so we use the stub instance 'path' (or 'uri') method to get the address back
    let uri = stubr.path(&quot;/hello&quot;);
    reqwest::get(uri).await
        // (optional) use asserhttp for assertions
        .expect_status_ok()
        .expect_content_type_text()
        .expect_body_text_eq(&quot;Hello stubr&quot;);
}</code></pre>
<p>But we can further shorten this with a attribute macro: <code>#[stubr::mock]</code></p>
<pre><code class="language-rust ignore noplayground edition2021">use asserhttp::*;

#[tokio::test]
#[stubr::mock(&quot;hello.json&quot;)] // ðŸ‘ˆ this starts the mock server
async fn getting_started() {
    // a local binding 'stubr' has been created, equivalent to the one before
    let uri = stubr.path(&quot;/hello&quot;);
    reqwest::get(uri)
        .await
        .expect_status_ok()
        .expect_content_type_text()
        .expect_body_text_eq(&quot;Hello stubr&quot;);
}</code></pre>
<p>You can also use the macro in non-async test methods of course, the macro will adapt by itself.<br />
Note that here you can omit the <code>tests/stubs/</code> path prefix. If you placed your files in the default location, they are
going to be searched from there.<br />
As well, you can mount many stubs with the macro e.g. <code>#[stubr::mock(&quot;hello.json&quot;, &quot;goodbye.json&quot;)]</code>.
By default, if you take care to place only stubs with different request matching under <code>tests/stubs</code>, you can simply
place <code>#[stubr::mock]</code>. It will recursively mount all the stubs under <code>tests/stubs</code>, searching also in subdirectories.</p>
<p>Here are all the options you can use with the attribute macro</p>
<pre><code class="language-rust ignore noplayground edition2021">#[tokio::test]
#[stubr::mock(full_path = &quot;tests/book/hello.json&quot;, port = 1234, verify = true)]
async fn getting_started() {}</code></pre>
<ul>
<li><code>full_path</code>: use this if your stubs are not under <code>tests/stubs</code> but elsewhere. Note that it can point to a directory.</li>
<li><code>port</code> when you want an explicit port for your mock server</li>
<li><code>verify</code> to turn on verification of the number of times a stub gets called (<code>expect</code> field in your stubs). 
See <a href="getting-started/../stubs/response.html#simulate-fault">simulating fault</a> for reference</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-2"><a class="header" href="#getting-started-2">Getting started</a></h1>
<p>You can use <a href="https://github.com/beltram/stubr">stubr</a> as a standalone mock server i.e. an executable. To learn more read the pages about how to use the
<a href="getting-started/../cli.html">cli</a> or <a href="getting-started/../docker.html">as a Docker image</a>.</p>
<p>For this short demo we are going to use the cli. We will create a http stub, mount it on a stub server and then call it
to verify it works.</p>
<h2 id="installation"><a class="header" href="#installation">installation</a></h2>
<h4 id="recommended"><a class="header" href="#recommended">recommended</a></h4>
<p><em>If you don't have it, install rustup from <a href="https://rustup.rs/">here</a>.</em></p>
<pre><code class="language-bash">cargo install stubr-cli
</code></pre>
<h4 id="or-from-precompiled-binaries"><a class="header" href="#or-from-precompiled-binaries">or from precompiled binaries</a></h4>
<p>Those binaries are stripped with <a href="https://upx.github.io/">upx</a> and then compressed. They are likely to be smaller than
the ones built by rustc which might be preferable in certain conditions</p>
<h6 id="macos"><a class="header" href="#macos">macos</a></h6>
<pre><code class="language-bash">curl -L https://github.com/beltram/stubr/releases/latest/download/stubr-macos.tar.gz | tar xz - -C /usr/local/bin
</code></pre>
<h6 id="linux"><a class="header" href="#linux">linux</a></h6>
<pre><code class="language-bash">curl -L https://github.com/beltram/stubr/releases/latest/download/stubr-linux.tar.gz | tar xz - -C /usr/local/bin
</code></pre>
<h6 id="windows"><a class="header" href="#windows">windows</a></h6>
<p>Install binary from <a href="https://github.com/beltram/stubr/releases/latest/download/stubr-windozs.zip">here</a>.</p>
<h2 id="hello-world-"><a class="header" href="#hello-world-">Hello world !</a></h2>
<p>We are going to create the simplest stub possible. It will accept any http method on any path and will respond <code>200 OK</code>.</p>
<pre><code class="language-bash">cat &gt; stub.json &lt;&lt;- EOF
{
  &quot;request&quot;: {
    &quot;method&quot;: &quot;ANY&quot;
  },
  &quot;response&quot;: {
    &quot;status&quot;: 200,
    &quot;body&quot;: &quot;Hello world !&quot;,
  }
}
EOF
</code></pre>
<p>A few things about a stub:</p>
<ul>
<li>It is a json file. First because it is the format supported by <a href="https://github.com/tomakehurst/wiremock">Wiremock</a> and
we want to be compatible with it. Also, most of the time, your http APIs will consume/produce json data in their
bodies. So you can inline the request/response body in this file without externalizing it.</li>
<li><code>request { .. }</code> is where we define <strong>request matching</strong> i.e. &quot;<em>conditions the incoming http request has to satisfy in
order for the response part to be served</em>&quot;</li>
<li><code>response { .. }</code> is the part where you define what the stub server will respond if all request matchings pass.</li>
</ul>
<h4 id="mount-it"><a class="header" href="#mount-it">mount it</a></h4>
<p>The cli can spawn a http server with a path to the file or folder containing json stubs. By default, it will try to bind
to a random port, here we force it to attach to port <code>8080</code>.</p>
<pre><code class="language-bash">stubr stub.json -p 8080 &amp;
</code></pre>
<h4 id="call-it"><a class="header" href="#call-it">call it</a></h4>
<p>Now let's verify our stub server is up and running and that it serves our stubs the right way.</p>
<pre><code class="language-bash">curl -i http://localhost:8080
</code></pre>
<p>Which should output:</p>
<pre><code class="language-bash">HTTP/1.1 200 OK
server: stubr(0.4.14)
content-length: 0
date: Fri, 22 Jul 2022 19:31:48 GMT

Hello world !%
</code></pre>
<p>or with httpie</p>
<pre><code class="language-bash">http :8080
</code></pre>
<h2 id="hello-name-"><a class="header" href="#hello-name-">Hello {name} !</a></h2>
<p>Now let's spice things a bit and make our stub a bit more dynamic by capturing a part of the request path and template
it in the response (this is called <a href="getting-started/../stubs/response.html">response templating</a>).</p>
<p>But first let's kill the previous server</p>
<pre><code class="language-bash">lsof -ti tcp:8080 | xargs kill
</code></pre>
<pre><code class="language-bash">cat &gt; hello.json &lt;&lt;- EOF
{
  &quot;request&quot;: {
    &quot;method&quot;: &quot;GET&quot;,
    &quot;urlPathPattern&quot;: &quot;/hello/(.+)&quot;
  },
  &quot;response&quot;: {
    &quot;status&quot;: 200,
    &quot;body&quot;: &quot;Hello {{request.pathSegments.[1]}} !&quot;,
    &quot;transformers&quot;: [&quot;response-template&quot;]
  }
}
EOF
</code></pre>
<p>Here:</p>
<ul>
<li><code>&quot;urlPathPattern&quot;: &quot;/hello/(.+)&quot;</code> is one way to express URL matching. It contains a regular hardcoded path <code>/hello/</code>
and a regular expression <code>(.+)</code> which has to match in order for the stub response to be served.</li>
<li><code>&quot;transformers&quot;: [&quot;response-template&quot;]</code> will activate response templating. This allows you to inject a part of the
request in the response. Prefer using it over hardcoded values when your real life application actually does that. The
more you use it the better your test accuracy will be.</li>
<li><code>{{request.pathSegments.[1]}}</code> now that response templating is enabled, you can inject parts of your request in the
response. With <a href="https://github.com/tomakehurst/wiremock">Wiremock</a> as with <a href="https://github.com/beltram/stubr">stubr</a>, we
use <a href="https://handlebarsjs.com/">handlebars</a> templates to do such a
thing. <a href="getting-started/../stubs/response.html">Many response templates are available</a> in <a href="https://github.com/beltram/stubr">stubr</a> in order to pick whatever part
of the request you want.</li>
</ul>
<h4 id="mount-it-1"><a class="header" href="#mount-it-1">Mount it</a></h4>
<pre><code class="language-bash">stubr hello.json -p 8080 &amp;
</code></pre>
<h4 id="call-it-1"><a class="header" href="#call-it-1">call it</a></h4>
<pre><code class="language-bash">curl -i http://localhost:8080/hello/stubr
</code></pre>
<p>Which should output:</p>
<pre><code class="language-bash">HTTP/1.1 200 OK
server: stubr(0.4.14)
content-type: text/plain
content-length: 13
date: Sat, 23 Jul 2022 09:25:42 GMT

Hello stubr !%
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract-testing"><a class="header" href="#contract-testing">Contract testing</a></h1>
<p>In order to introduce contract testing in the simplest terms, we'll go through a mixed practice interleaved with as
much documentation as possible. The main idea behind this testing practice is to be able to <strong>quickly spot breaking API
changes</strong> between a producer and a consumer. All of this process should be <strong>offline</strong>, <strong>deterministic</strong> and <strong>should
not</strong> involve spawning any real http application locally !!! If you want to learn more about the concept, I warmly
invite you to read <a href="https://martinfowler.com/bliki/ContractTest.html">what Martin Fowler has to say about it</a>.</p>
<p>It <strong>must not</strong> be confused with end-to-end tests as it does not aim at all to replace them ; it's the opposite
actually, they are complementary. Their goal is to have the shortest feedback loop possible are detect early on mistakes
before running those onerous e2e CI pipelines where you'll get the confidence that your code is ready to be shipped in
production.</p>
<h2 id="what-is-it-"><a class="header" href="#what-is-it-">What is it ?</a></h2>
<p>Contract test <strong>are not</strong> about testing functional things ! To be more explicit, imagine you have a <code>User</code>
endpoint with the following json response:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;alice&quot;,
  &quot;age&quot;: 42
}
</code></pre>
<p>Given this endpoint, your contract test will just verify that <code>&quot;name&quot;</code> is a json string and <code>&quot;age&quot;</code> a json number,
that's it ! On the other hand, your e2e test will probably create a user Alice with age 42 and then verify that your
endpoint returns the exact same data with the same values.</p>
<h2 id="producer--consumer"><a class="header" href="#producer--consumer">Producer &amp; consumer</a></h2>
<pre><code class="language-mermaid">graph LR
  C[Consumer] --&gt; |http| P[Producer]
</code></pre>
<p>Most of the time you will use this kind of testing when you have many application communicating over http. In this
situation we will call:</p>
<ul>
<li><code>producer</code>: the application exposing a http API (could be REST or SOAP for what it's worth). We will write one (or
many) stubs for each http endpoint. We could as well write stubs once and then let them rot. The risk would be that
while the API evolves, our stub stops representing it accurately. To prevent that, we will <code>verify</code> the stubs we write
i.e. we will generate real http requests from the stubs and run them against a real instance of the application to
assert that it does what it claims in the stub. And now we can confidently share our stubs with the outside world and
our consumers.</li>
<li><code>consumer</code>: application with a http client calling a producer http application. The consumer first has to fetch stubs
exposed by the producer. Then it can mount them with <a href="https://github.com/beltram/stubr">stubr</a> to mock the producer in its unit tests. It brings the
consumer the benefits of being able to lean on verified stubs and to carefully pick a specific version of the
producer. Along its lifetime, whenever the producer releases a new version, the consumer will be able, even in a
semi-automated way (dependabot), to verify it is still compatible with the producer API.</li>
</ul>
<h2 id="producerconsumer-driven"><a class="header" href="#producerconsumer-driven">Producer/consumer driven</a></h2>
<p>There are 2 schools when it comes to contract testing: producer-driven &amp; consumer-driven.</p>
<p>In consumer-driven (for example <a href="https://docs.pact.io/">Pact</a>), multiple consumers define the contract which then has to
be respected by the producer (summarizing). This has the advantage of taking into consideration every single consumer
but has some drawbacks. First, every consumer has to manually write/copy the same producer mock ; imagine a microservice
fleet with a producer consumed 100 times, hence its mocks re-defined in all 100 consumers. Then, anytime a consumer
produces a new version, a complex CI workflow has to be triggered to verify that the contract is respected by the
producer. In conclusion, it is not offline.</p>
<p>Producer-driven (for example <a href="https://spring.io/projects/spring-cloud-contract">Spring Cloud Contract</a>) on the other
hand has the advantage of being straightforward. Producer defines the contract once, publishes it and every consumer has
to adapt. Compared to consumer-driven, this model is better suited for organizations where a team has ownership of all
the applications (when contract definition is easy). It has the major advantage of being offline and not requiring more
than 1 definition of the contract. <strong><a href="https://github.com/beltram/stubr">Stubr</a> is producer-driven</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="as-a-producer"><a class="header" href="#as-a-producer">As a producer</a></h1>
<p>We'll use actix in those examples because it is the only web framework currently supported for verifying the producer,
others will come ! And of course it does not impact the consumer where you can use any technology you want since <a href="https://github.com/beltram/stubr">stubr</a>
can be used <a href="contract/../getting-started/standalone.html">standalone</a> (you can even use a language other than Rust !).</p>
<h2 id="endpoint"><a class="header" href="#endpoint">endpoint</a></h2>
<p>We'll begin in a very common situation where your producer exposes a http endpoint. We will make the endpoint as simple
and stupid as possible with a flat <code>Beer</code> resource and an in-memory database. We'll just expose an endpoint for creating
and fetching a resource which should cover most of the use cases.</p>
<pre><code class="language-rust ignore noplayground edition2021">use actix_web::http::header::ContentType;
use actix_web::web;

// simple in-memory database
pub type Database = std::sync::RwLock&lt;std::collections::HashMap&lt;u32, Beer&gt;&gt;;

#[actix_web::post(&quot;/beers&quot;)]
pub async fn create(mut beer: web::Json&lt;Beer&gt;, db: web::Data&lt;Database&gt;) -&gt; impl actix_web::Responder {
    let exists = db.read().unwrap().iter().any(|(_, b)| &amp;beer.0 == b);
    if !exists {
        let next_id = db.read().unwrap().len() as u32;
        beer.id = Some(next_id);
        db.write().unwrap().insert(next_id, beer.clone());
        actix_web::HttpResponse::Created()
            .content_type(ContentType::json())
            .body(serde_json::to_string(&amp;beer).unwrap())
    } else {
        actix_web::HttpResponse::Conflict()
            .content_type(ContentType::json())
            .body(serde_json::json!({&quot;message&quot;: &quot;Beer already exists&quot;}).to_string())
    }
}

#[actix_web::get(&quot;/beers/{id}&quot;)]
pub async fn find_by_id(path: web::Path&lt;u32&gt;, db: web::Data&lt;Database&gt;) -&gt; impl actix_web::Responder {
    let id = path.into_inner();
    if let Some(beer) = db.read().unwrap().get(&amp;id) {
        actix_web::HttpResponse::Ok()
            .content_type(ContentType::json())
            .body(serde_json::to_string(beer).unwrap())
    } else {
        actix_web::HttpResponse::NotFound()
            .content_type(ContentType::json())
            .body(serde_json::json!({&quot;message&quot;: &quot;Beer not found&quot;}).to_string())
    }
}

#[derive(Debug, Clone, Eq, serde::Serialize, serde::Deserialize)]
pub struct Beer {
    pub id: Option&lt;u32&gt;,
    pub name: String,
    pub price: u32,
}

impl PartialEq for Beer {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.name == other.name
    }
}</code></pre>
<h2 id="tests"><a class="header" href="#tests">tests</a></h2>
<p>Then as we do things seriously, we will write some tests. For the <code>create</code> endpoint we'll have a nominal case where the 
beer we create succeeds and another negative one where it fails because we have a uniqueness constraint on the Beer's 
<code>name</code> and <code>price</code> fields. For the <code>find_by_id</code> one, we'll have a nominal case and a <code>404 Not Found</code> one.</p>
<pre><code class="language-rust ignore noplayground edition2021">use actix_web::{
    test::{call_service, init_service, TestRequest},
    web, App,
};
use asserhttp::*;

use actix_producer::api::beer::*;

mod find_by_id {
    use super::*;

    #[actix_web::test]
    async fn find_by_id_should_find_one() {
        let app = App::new()
            .app_data(sample_db())
            .service(find_by_id)
            .wrap(stubr::ActixRecord::default()); // ðŸ‘ˆ record
        let beers = sample();
        let (id, to_find) = beers.get(0).unwrap();
        let req = TestRequest::get().uri(&amp;format!(&quot;/beers/{id}&quot;)).to_request();
        call_service(&amp;init_service(app).await, req)
            .await
            .expect_status_ok()
            .expect_content_type_json()
            .expect_body_json(|b: Beer| assert_eq!(&amp;b, to_find));
    }

    #[actix_web::test]
    async fn find_by_id_should_not_find_any() {
        let app = App::new()
            .app_data(sample_db())
            .service(find_by_id)
            .wrap(stubr::ActixRecord::default()); // ðŸ‘ˆ record
        let req = TestRequest::get().uri(&quot;/beers/999&quot;).to_request();
        call_service(&amp;init_service(app).await, req).await.expect_status_not_found();
    }
}

mod create {
    use super::*;

    #[actix_web::test]
    async fn create_should_create_one() {
        let beer = Beer {
            id: None,
            name: &quot;Heineken&quot;.to_string(),
            price: 4,
        };
        let app = App::new()
            .app_data(empty_db())
            .service(create)
            .wrap(stubr::ActixRecord::default()); // ðŸ‘ˆ record
        let req = TestRequest::post().uri(&quot;/beers&quot;).set_json(beer.clone()).to_request();
        call_service(&amp;init_service(app).await, req)
            .await
            .expect_status_created()
            .expect_content_type_json()
            .expect_body_json(|b: Beer| {
                assert!(b.id.is_some());
                assert_eq!(b.name, beer.name);
                assert_eq!(b.price, beer.price);
            });
    }

    #[actix_web::test]
    async fn create_should_conflict_when_already_exists_by_name() {
        let (_id, beer) = sample().get(0).unwrap().clone();
        let app = App::new()
            .app_data(sample_db())
            .service(create)
            .wrap(stubr::ActixRecord::default()); // ðŸ‘ˆ record
        let req = TestRequest::post().uri(&quot;/beers&quot;).set_json(beer.clone()).to_request();
        call_service(&amp;init_service(app).await, req).await.expect_status_conflict();
    }
}

pub fn sample_db() -&gt; web::Data&lt;Database&gt; {
    web::Data::new(std::sync::RwLock::new(sample().into()))
}

pub fn empty_db() -&gt; web::Data&lt;Database&gt; {
    web::Data::new(std::sync::RwLock::new([].into()))
}

pub fn sample() -&gt; [(u32, Beer); 2] {
    [
        (
            0,
            Beer {
                id: Some(0),
                name: &quot;Leffe&quot;.to_string(),
                price: 5,
            },
        ),
        (
            1,
            Beer {
                id: Some(1),
                name: &quot;1664&quot;.to_string(),
                price: 3,
            },
        ),
    ]
}</code></pre>
<h2 id="recording"><a class="header" href="#recording">recording</a></h2>
<p>Although it is optional, we'll use <a href="contract/../recording/actix.html">recording</a> here to easily create one stub for each test. 
Recording is triggered by the <code>.wrap(stubr::ActixRecord::default())</code> line. Those recorded stubs will be in 
<code>target/stubs/localhost</code>. </p>
<h2 id="import-stubs"><a class="header" href="#import-stubs">import stubs</a></h2>
<p>In order for a producer to expose stubs, they have to live in a <code>stubs</code> folder in the root of your project. So 
copy/paste the 4 recorded stubs into this folder and arrange them a bit (remove recording noise) to match the following.</p>
<details>
<summary><b>create</b></summary>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;method&quot;: &quot;POST&quot;,
    &quot;urlPath&quot;: &quot;/beers&quot;,
    &quot;headers&quot;: {
      &quot;content-type&quot;: {
        &quot;equalTo&quot;: &quot;application/json&quot;
      }
    },
    &quot;bodyPatterns&quot;: [
      {
        &quot;equalToJson&quot;: {
          &quot;name&quot;: &quot;Heineken&quot;,
          &quot;price&quot;: 4
        }
      }
    ]
  },
  &quot;response&quot;: {
    &quot;status&quot;: 201,
    &quot;jsonBody&quot;: {
      &quot;id&quot;: 2,
      &quot;name&quot;: &quot;Heineken&quot;,
      &quot;price&quot;: 4
    },
    &quot;headers&quot;: {
      &quot;content-type&quot;: &quot;application/json&quot;
    }
  }
}
</code></pre>
</details>
<details>
<summary><b>create with name conflict</b></summary>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;method&quot;: &quot;POST&quot;,
    &quot;urlPath&quot;: &quot;/beers&quot;,
    &quot;headers&quot;: {
      &quot;content-type&quot;: {
        &quot;equalTo&quot;: &quot;application/json&quot;
      }
    },
    &quot;bodyPatterns&quot;: [
      {
        &quot;equalToJson&quot;: {
          &quot;name&quot;: &quot;Leffe&quot;,
          &quot;price&quot;: 5
        }
      }
    ]
  },
  &quot;response&quot;: {
    &quot;status&quot;: 409,
    &quot;jsonBody&quot;: {
      &quot;message&quot;: &quot;Beer already exists&quot;
    },
    &quot;headers&quot;: {
      &quot;content-type&quot;: &quot;application/json&quot;
    }
  }
}
</code></pre>
</details>
<details>
<summary><b>find by id</b></summary>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;method&quot;: &quot;GET&quot;,
    &quot;urlPath&quot;: &quot;/beers/0&quot;
  },
  &quot;response&quot;: {
    &quot;status&quot;: 200,
    &quot;jsonBody&quot;: {
      &quot;id&quot;: 0,
      &quot;name&quot;: &quot;Leffe&quot;,
      &quot;price&quot;: 5
    },
    &quot;headers&quot;: {
      &quot;content-type&quot;: &quot;application/json&quot;
    }
  }
}
</code></pre>
</details>
<details>
<summary><b>find by id not found</b></summary>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;method&quot;: &quot;GET&quot;,
    &quot;urlPath&quot;: &quot;/beers/404&quot;
  },
  &quot;response&quot;: {
    &quot;status&quot;: 404,
    &quot;jsonBody&quot;: {
      &quot;message&quot;: &quot;Beer not found&quot;
    },
    &quot;headers&quot;: {
      &quot;content-type&quot;: &quot;application/json&quot;
    }
  }
}
</code></pre>
</details>
<h2 id="verify"><a class="header" href="#verify">verify</a></h2>
<p>And finally, we have to verify that the stubs exposed by our producer match the actual implementation. To do so, <a href="https://github.com/beltram/stubr">stubr</a>
exports the <code>StubrVerify</code> trait with the <code>.verify()</code> method you have to invoke. There is no automatic verification of
stubs possible, it has to be explicit in a test. It is advised to declare it in a file with just the verification test.</p>
<p>Such a test will start by declaring your actix app with all the endpoints. In order to verify it, <a href="https://github.com/beltram/stubr">stubr</a> will create a
test for every stub in <code>./stubs</code> by converting, for each, the <code>request</code> part in an actual actix integration test.</p>
<p>But you might need some state ! For example, think of the <code>find by id</code> endpoint. It cannot be verified if your database
is empty. Likewise, stubs are verified in no particular order (since anyway your endpoint are most likely stateless, 
right ?). Executing some tests (for example a &quot;delete&quot; endpoint) might affect others. So before each test, we have to
reset our application state. You can do that with the <code>stubr::ActixVerifyLifecycle</code> middleware, for example here to
wipe our database then populate it with our sample data (it is recommended to reuse the same as in your tests).</p>
<p>Finally, call <code>.verify()</code> (a bit different in our example) to launch the verification test. If it passes, you have the
guarantee your stubs accurately represent your application API. </p>
<pre><code class="language-rust ignore noplayground edition2021">use crate::api::beer::*;
use actix_producer::api::beer::*;

#[actix_web::test]
async fn should_verify() {
    use stubr::StubrVerify as _;

    actix_web::App::new()
        .app_data(sample_db())
        .service(create)
        .service(find_by_id)
        // reset application state
        .wrap(stubr::ActixVerifyLifecycle::&lt;Database&gt;(|db| {
            let mut db = db.write().unwrap();
            db.clear();
            for (i, beer) in sample() {
                db.insert(i, beer);
            }
        }))
        // required because this sample lives in a project with other stubs.
        // Otherwise just use '.verify()'
        .verify_except(|stub_name: &amp;str| stub_name.starts_with(&quot;pet-&quot;))
        .await;
}</code></pre>
<p>Now let's use those stubs in a consumer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="as-a-consumer"><a class="header" href="#as-a-consumer">As a consumer</a></h1>
<p>We will now consume the stubs we have verified on the <a href="contract/producer.html">producer</a> side. It actually does not change from 
when you mount regular stubs, you will just use different helpers here.</p>
<h2 id="importing"><a class="header" href="#importing">importing</a></h2>
<p>So we have some stubs defined in a Rust project, let's call it <code>actix-producer</code>. On naive way to deal with this would 
be to simply copy/paste stubs from producer to consumer. That'd work, obviously ; but we would be too cumbersome to
maintain and way too error-prone. We need a more automated way to import those stubs.</p>
<p>Here comes <a href="https://crates.io/crates/stubr-build">stubr-build</a>. It's a simple build dependency which will scan your
build dependencies and look for producers (projects with a root <code>stubs</code> folder with json stubs underneath). For each, it
will copy/paste those stubs under <code>target/stubr/{consumer-name}/{producer-name}</code>. This default location will be used 
later on to mount the stubs.</p>
<p>To begin with, add <a href="https://crates.io/crates/stubr-build">stubr-build</a> to your build dependencies. Then also add the
producers (here we will use <code>actix-producer</code>).</p>
<pre><code class="language-toml">[build-dependencies]
stubr-build = &quot;0.6.1&quot;
actix-producer = &quot;0.1.0&quot;
</code></pre>
<p>Then, in a build script, invoke <a href="https://crates.io/crates/stubr-build">stubr-build</a> and do <code>cargo build</code></p>
<pre><code class="language-rust ignore noplayground edition2021">fn main() {
    stubr_build::stubr_consumer()
}</code></pre>
<p>Verify your stubs have been imported (given your consumer project is called <code>actix-consumer</code>), you should have 
something like this under <code>target/stubr</code>:</p>
<pre><code class="language-text">â”œâ”€â”€ actix-consumer
â”‚ â””â”€â”€ actix-producer
â”‚   â”œâ”€â”€ beer-create-conflict-name.json
â”‚   â”œâ”€â”€ beer-create.json
â”‚   â”œâ”€â”€ beer-find-by-id-not-found.json
â”‚   â””â”€â”€ beer-find-by-id.json
</code></pre>
<h2 id="consuming"><a class="header" href="#consuming">consuming</a></h2>
<p>At this point, your consumer app could be anything: either another actix application, or a web application using a
different framework, or a simple cli or batch relying on a http client to call your producer. It does not matter. Here,
we'll assume the simplest use case (a simple blocking http client using reqwest) but it does not make any difference.</p>
<p>We will use the <code>apps</code> attribute macro to mount the stubs we just imported in our stub server. And for our tests. we
will just import the stubs of the <code>actix-producer</code> app we created previously. To do so, add 
<code>#[stubr::apps(&quot;actix-producer&quot;)]</code> on your test method (note that you can use it to mount many apps e.g. 
<code>#[stubr::apps(&quot;svc-a&quot;, &quot;svc-b&quot;)]</code>). This will create a local binding with the name of your app.</p>
<pre><code class="language-rust ignore noplayground edition2021">#[test]
#[stubr::apps(&quot;actix-producer&quot;)]
fn sample_binding() {
    let actix_producer: stubr::Stubr = actix_producer;
    let _uri: String = actix_producer.uri();
}</code></pre>
<p>You can then use this binding to get the uri(s) of the mock server(s) and execute your tests against it.</p>
<pre><code class="language-rust ignore noplayground edition2021">use asserhttp::*;
use serde_json::json;

#[test]
#[stubr::apps(&quot;actix-producer&quot;)]
fn find_by_id_should_find_one() {
    let uri: String = actix_producer.uri();
    let beer_id = 0;
    reqwest::blocking::get(format!(&quot;{uri}/beers/{beer_id}&quot;))
        .expect_status_ok()
        .expect_content_type_json()
        .expect_body_json_eq(json!({
            &quot;id&quot;: 0,
            &quot;name&quot;: &quot;Leffe&quot;,
            &quot;price&quot;: 5
        }));
}

#[test]
#[stubr::apps(&quot;actix-producer&quot;)]
fn find_by_id_should_not_find_any() {
    let uri: String = actix_producer.uri();
    reqwest::blocking::get(format!(&quot;{uri}/beers/404&quot;))
        .expect_status_not_found()
        .expect_content_type_json()
        .expect_body_json_eq(json!({
            &quot;message&quot;: &quot;Beer not found&quot;
        }));
}

#[test]
#[stubr::apps(&quot;actix-producer&quot;)]
fn create_should_create_one() {
    let uri: String = actix_producer.uri();
    reqwest::blocking::Client::new()
        .post(format!(&quot;{uri}/beers&quot;))
        .json(&amp;json!({
            &quot;name&quot;: &quot;Heineken&quot;,
            &quot;price&quot;: 4
        }))
        .send()
        .expect_status_created()
        .expect_content_type_json()
        .expect_body_json(|beer: serde_json::Value| {
            assert!(beer.get(&quot;name&quot;).unwrap().is_string());
            assert!(beer.get(&quot;price&quot;).unwrap().is_u64());
        });
}

#[test]
#[stubr::apps(&quot;actix-producer&quot;)]
fn create_should_should_conflict_on_name() {
    let uri: String = actix_producer.uri();
    reqwest::blocking::Client::new()
        .post(format!(&quot;{uri}/beers&quot;))
        .json(&amp;json!({
            &quot;name&quot;: &quot;Leffe&quot;,
            &quot;price&quot;: 5
        }))
        .send()
        .expect_status_conflict()
        .expect_content_type_json()
        .expect_body_json_eq(json!({
            &quot;message&quot;: &quot;Beer already exists&quot;
        }));
}</code></pre>
<p>And that's all folks ! We have consumed our producer stubs. But those stubs only have hardcoded values and will be hard 
to change and maintain. We'll now see how to relax them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relaxing-your-stubs"><a class="header" href="#relaxing-your-stubs">Relaxing your stubs</a></h1>
<p>Whenever you are maintaining a large cohort of interconnected services, you more often than not will opt for Test Data
e.g. a user with firstname <code>john</code> and lastname <code>doe</code>. And then use this same sample user in all your services tests.
That works actually quite well. That's actually what we did previously, for example</p>
<details open="true">
<summary><b>in this stub</b></summary>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;method&quot;: &quot;POST&quot;,
    &quot;urlPath&quot;: &quot;/beers&quot;,
    &quot;headers&quot;: {
      &quot;content-type&quot;: {
        &quot;equalTo&quot;: &quot;application/json&quot;
      }
    },
    &quot;bodyPatterns&quot;: [
      {
        &quot;equalToJson&quot;: {
          &quot;name&quot;: &quot;Heineken&quot;,
          &quot;price&quot;: 4
        }
      }
    ]
  },
  &quot;response&quot;: {
    &quot;status&quot;: 201,
    &quot;jsonBody&quot;: {
      &quot;id&quot;: 2,
      &quot;name&quot;: &quot;Heineken&quot;,
      &quot;price&quot;: 4
    },
    &quot;headers&quot;: {
      &quot;content-type&quot;: &quot;application/json&quot;
    }
  }
}
</code></pre>
</details>
<p>With such a stub, we can imagine we would end up with a test in our consumer like that:</p>
<pre><code class="language-rust ignore noplayground edition2021">#[test]
#[stubr::apps(&quot;actix-producer&quot;)]
fn create_should_create_one() {
    let uri: String = actix_producer.uri();
    reqwest::blocking::Client::new()
        .post(format!(&quot;{uri}/beers&quot;))
        .json(&amp;json!({
            &quot;name&quot;: &quot;Heineken&quot;,
            &quot;price&quot;: 4
        }))
        .send()
        .expect_status_created()
        .expect_content_type_json()
        .expect_body_json(|beer: serde_json::Value| {
            assert!(beer.get(&quot;name&quot;).unwrap().is_string());
            assert!(beer.get(&quot;price&quot;).unwrap().is_u64());
        });
}</code></pre>
<p>Notice the request data in this test. Here, this sample is really dummy but in a real application, <code>name</code> is likely to
come from the consumer's own Test Data. But it cannot be any value ; remember, the producer API requires <code>name</code> to be
unique. So both producer and consumer Test Data, are now tightly coupled. We are also having specific expectations
regarding the response, for example we are expecting the beer name to be <code>Heineken</code> and its price <code>4</code> (in this situation
you could also relax your test, but sometimes you can't). And in a big system, your consumer is probably also a
producer, so all its stubs are also going to contain <code>Heineken</code> and <code>4</code>.</p>
<h2 id="when-things-change"><a class="header" href="#when-things-change">When things change</a></h2>
<p>Things always change. Sometimes, their format does, for example our beer price can change from <del><code>4</code></del> to <code>&quot;4.00&quot;</code> ;
that's fine, contract testing is made to catch those changes. But imagine if, for whatever functional reason, now prices
in your system can no longer contain 0 cent by needs to be 99 cent: all your Test Data have to change. Now imagine your
system is made of hundreds of microservices, all requiring this beer service. That's a shame, and all because some Test
Data in a single service has changed.</p>
<p>This could have been avoided if we had taken some time to make our stubs relax its request expectation and also return
randomized response data.</p>
<h2 id="relaxing-fields"><a class="header" href="#relaxing-fields">Relaxing fields</a></h2>
<p>Here we will get rid of all the hardcoded data in the response (currently there are not enough helpers to also relax
the request data with <a href="https://github.com/beltram/stubr">stubr</a>, but it will be possible one day).</p>
<p>We will first randomize the id with <a href="contract/../stubs/response.html#relaxed-field">anyU32</a>. On the consumer side, this will
generate a random <code>u32</code>. On the producer side in the <a href="contract/producer.html#verify">verifier tests</a>, it simply asserts that the
field is a <code>u32</code>.</p>
<p>Now, for the other fields, those are directly taken from the request, so we'll
use <a href="contract/../stubs/response.html#response-templating">response templating helpers</a> to forward them from the request.</p>
<p>We end up with a stub like this:</p>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;method&quot;: &quot;POST&quot;,
    &quot;urlPath&quot;: &quot;/beers&quot;,
    &quot;headers&quot;: {
      &quot;content-type&quot;: {
        &quot;equalTo&quot;: &quot;application/json&quot;
      }
    },
    &quot;bodyPatterns&quot;: [
      {
        &quot;equalToJson&quot;: {
          &quot;name&quot;: &quot;Heineken&quot;,
          &quot;price&quot;: 4
        }
      }
    ]
  },
  &quot;response&quot;: {
    &quot;status&quot;: 201,
    &quot;jsonBody&quot;: {
      &quot;id&quot;: &quot;{{anyI32}}&quot;,
      &quot;name&quot;: &quot;{{jsonPath request.body '$.name'}}&quot;,
      &quot;price&quot;: &quot;{{jsonPath request.body '$.price'}}&quot;
    },
    &quot;headers&quot;: {
      &quot;content-type&quot;: &quot;application/json&quot;
    },
    &quot;transformers&quot;: [&quot;response-template&quot;]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stubs"><a class="header" href="#stubs">Stubs</a></h1>
<p>Writing stubs can be challenging and time-consuming. <a href="https://github.com/beltram/stubr">Stubr</a> tries to assist by
providing <a href="stubs/../ide-completion.html">IDE completion</a> or by <a href="stubs/../recording/index.html">recording</a> live traffic into stubs. But
you still have to know how to write a stub and what helpers you have in order to <a href="stubs/../contract/relaxing.html">relax</a> your stubs as much
as possible.</p>
<p>You will find here in a single snippet <strong>ALL</strong> the fields/helpers available to you:</p>
<pre><code class="language-json">{
  &quot;id&quot;: &quot;82d86e05-9ee0-44ca-9a8d-1fc6f719437e&quot;, // (optional) unique stub identifier. Returned in 'Matched-Stub-Id' header
  &quot;priority&quot;: 1, // (optional) helps solving interlaced conditions (many stubs match the request). 1 is the highest priority, 255 the lowest
  &quot;request&quot;: {
    &quot;method&quot;: &quot;GET&quot;, // (optional) http method. Can be &quot;ANY&quot; to match any method. Defaults to &quot;ANY&quot;
    &quot;urlPath&quot;: &quot;/api/exact-uri&quot;, // exact URI match
    &quot;urlPathPattern&quot;: &quot;/api/regex-uri/([a-z]{4})&quot;, // URI must match regex
    &quot;urlPattern&quot;: &quot;/api/regex-uri/([a-z]{4})\\?and=([a-z]{4})&quot;, // URI &amp; query must match regex
    &quot;url&quot;: &quot;/api/uri?age=young&quot;, // raw URI + query parameters by equality matching
    &quot;queryParameters&quot;: {
      &quot;firstname&quot;: { &quot;equalTo&quot;: &quot;beltram&quot; }, // by equality matching (can also be an int, or a boolean)
      &quot;lastname&quot;: { &quot;equalTo&quot;: &quot;maldant&quot;, &quot;caseInsensitive&quot;: true }, // case insensitve equality
      &quot;age&quot;: { &quot;absent&quot;: true }, // must be absent
      &quot;city&quot;: { &quot;contains&quot;: &quot;a&quot; }, // must contain the letter 'a'
      &quot;title&quot;: { &quot;matches&quot;: &quot;([A-Za-z]+)&quot; }, // must match regex
      &quot;job&quot;: { &quot;doesNotMatch&quot;: &quot;([A-Za-z]+)&quot; }, // or must not match regex
    },
    &quot;headers&quot;: {
      &quot;content-type&quot;: { &quot;equalTo&quot;: &quot;application/json&quot; } // by equality matching
      // .. then all matchers described above for query parameters are also applicable here
    },
    &quot;basicAuth&quot; : { // exact Basic authentication matching
      &quot;username&quot;: &quot;user&quot;,
      &quot;password&quot;: &quot;pass&quot;
    },
    &quot;jwtAuth&quot;: {
      &quot;equalTo&quot;: &quot;eyJhbGciOiJSUzI1NiJ9.e30.MBkQ...&quot;, // plain JWT token
      &quot;alg&quot;: {
        &quot;equalTo&quot;: &quot;RS256&quot;, // JWT algorithm by equality matcher
        &quot;oneOf&quot;: [&quot;RS256&quot;, &quot;HS256&quot;] // JWT must contain one of these algorithms
      },
      &quot;payloadPatterns&quot;: [
        // all matchers available in 'bodyPatterns' â¬‡ï¸
      ]
    },
    &quot;bodyPatterns&quot;: [
      { &quot;equalToJson&quot;: {&quot;name&quot;: &quot;bob&quot;} }, // strict json request body equality
      { &quot;equalToJson&quot;: {&quot;name&quot;: &quot;bob&quot;}, &quot;ignoreExtraElements&quot;: true }, // ignore extra json fields supplied in request body. Default to false.
      { &quot;equalToJson&quot;: {&quot;name&quot;: &quot;bob&quot;}, &quot;ignoreArrayOrder&quot;: true }, // ignore array items order. Default to false.
      { &quot;matchesJsonPath&quot;: &quot;$.name&quot; }, // must just match json path
      { &quot;matchesJsonPath&quot;: &quot;$.consoles[?(@.name == 'xbox')]&quot; }, // must match json path + equality
      { &quot;matchesJsonPath&quot;: &quot;$.consoles[?(@.price &gt; 200)]&quot; }, // must match json path + bound
      { &quot;expression&quot;: &quot;$.name&quot;, &quot;contains&quot;: &quot;at&quot; }, // must match json path + contain the string 'at'
      { &quot;expression&quot;: &quot;$.user&quot;, &quot;equalToJson&quot;: { &quot;name&quot;: &quot;bob&quot; } }, // must match json path + be equal
      { &quot;binaryEqualTo&quot;: &quot;AQID&quot; /* Base 64 */ } // byte array equality
    ]
  },
  &quot;response&quot;: {
    &quot;status&quot;: 200, // (required) response status
    &quot;fixedDelayMilliseconds&quot;: 2000, // delays response by 2 seconds
    &quot;delayDistribution&quot;: { // a random delay..
      &quot;type&quot;: &quot;lognormal&quot;, // ..with logarithmic distribution
      &quot;median&quot;: 100, // The 50th percentile of latencies in milliseconds
      &quot;sigma&quot;: 0.1 // Standard deviation. The larger the value, the longer the tail
    },
    &quot;jsonBody&quot;: { // json response body (automatically adds 'content-type:application/json' header)
      &quot;name&quot;: &quot;john&quot;,
      &quot;surnames&quot;: [ &quot;jdoe&quot;, &quot;johnny&quot; ]
    },
    &quot;body&quot;: &quot;Hello World !&quot;, // text response (automatically adds 'Content-Type:text/plain' header)
    &quot;base64Body&quot;: &quot;AQID&quot;, // binary Base 64 body
    &quot;bodyFileName&quot;: &quot;tests/stubs/response.json&quot;, // path to a .json or .txt file containing the response
    &quot;bodyFileName&quot;: &quot;tests/stubs/{{request.pathSegments.[1]}}.json&quot;, // supports templating
    &quot;headers&quot;: {
      &quot;content-type&quot;: &quot;application/pdf&quot; // returns this response header
    },
    // ..now response templating
    // it uses handlebars and allows you to define dynamic response based upon the content of the request
    // it can be used in &quot;jsonBody&quot;, &quot;body&quot;, &quot;bodyFileName&quot; or &quot;headers&quot;
    &quot;transformers&quot;: [&quot;response-template&quot;], // required to activate response templating
    &quot;jsonBody&quot;: {
      &quot;url-path-and-query&quot;: &quot;{{request.url}}&quot;,
      &quot;url-path&quot;: &quot;{{request.path}}&quot;,
      &quot;url-path-segments&quot;: &quot;{{request.pathSegments.[1]}}&quot;, // returns 'two' given '/one/two/three' path
      &quot;query&quot;: &quot;{{request.query.kind}}&quot;, // returns 'comics' given '/api/books?kind=comics'
      &quot;multi-query&quot;: &quot;{{request.query.kind.[1]}}&quot;, // returns 'novel' given '/api/books?kind=comics&amp;kind=novel'
      &quot;method&quot;: &quot;{{request.method}}&quot;, // http request method e.g. &quot;POST&quot;
      &quot;header&quot;: &quot;{{request.headers.Content-Type}}&quot;, // returns request header with given key
      &quot;multi-header&quot;: &quot;{{request.headers.cache-control.[0]}}&quot;, // returns first value of &quot;cache-control&quot; values
      &quot;body&quot;: &quot;{{request.body}}&quot;, // returns raw request body
      &quot;from-request&quot;: &quot;{{jsonPath request.body '$.name'}}&quot;, // takes field 'name' from json request body
      &quot;now&quot;: &quot;{{now}}&quot;, // current datetime (UTC)
      &quot;now-fmt&quot;: &quot;{{now format='yyyy/MM/dd'}}&quot;, // with custom Java SimpleDateFormat
      &quot;now-fmt-epoch&quot;: &quot;{{now format='epoch'}}&quot;, // epoch in milliseconds
      &quot;now-fmt-unix&quot;: &quot;{{now format='unix'}}&quot;, // epoch in seconds
      &quot;now-positive-offset&quot;: &quot;{{now offset='3 days'}}&quot;, // human time positive offset
      &quot;now-negative-offset&quot;: &quot;{{now offset='-3 days'}}&quot;, // human time negative offset
      &quot;now-with-timezone&quot;: &quot;{{now timezone='Europe/Rome'}}&quot;,
      &quot;number-is-odd&quot;: &quot;{{isOdd 3}}&quot;, // or 'isEven'
      &quot;string-capitalized&quot;: &quot;{{capitalize mister}}&quot;, // or 'decapitalize'
      &quot;string-uppercase&quot;: &quot;{{upper mister}}&quot;, // or 'lower'
      &quot;number-stripes&quot;: &quot;{{stripes request.body 'if-even' 'if-odd'}}&quot;,
      &quot;string-trim&quot;: &quot;{{trim request.body}}&quot;, // removes leading &amp; trailing whitespaces
      &quot;size&quot;: &quot;{{size request.body}}&quot;, // string length or array length
      &quot;base64-encode&quot;: &quot;{{base64 request.body padding=false}}&quot;, // padding is optional and defaults to true
      &quot;base64-decode&quot;: &quot;{{base64 request.body decode=true}}&quot;,
      &quot;url-encode&quot;: &quot;{{urlEncode request.header.x-raw}}&quot;,
      &quot;url-decode&quot;: &quot;{{urlEncode request.header.x-encoded decode=true}}&quot;,
      // you can also use 'any*' helpers. They will produce a random value
      &quot;regex&quot;: &quot;{{anyRegex '[a-z]{4}'}}&quot;, // generate a random string matching regex
      &quot;string&quot;: &quot;{{anyNonEmptyString}}&quot;, // or '{{anyNonEmptyString}}'
      &quot;alphanum&quot;: &quot;{{anyAlphaNumeric}}&quot;,
      &quot;boolean&quot;: &quot;{{anyBoolean}}&quot;,
      &quot;uuid&quot;: &quot;{{anyUuid}}&quot;,
      &quot;ip&quot;: &quot;{{anyIpAddress}}&quot;, // e.g. '127.0.0.1'
      &quot;host&quot;: &quot;{{anyHostname}}&quot;, // e.g. 'https://github.com'
      &quot;email&quot;: &quot;{{anyEmail}}&quot;, // e.g. 'john.doe@gmail.com'
      &quot;enum&quot;: &quot;{{anyOf 'alpha' 'beta' 'gamma'}}&quot;, // returns randomly one of those 3 values
      &quot;number&quot;: &quot;{{anyNumber}}&quot;, // integer or float 
      &quot;integer&quot;: &quot;{{anyI32}}&quot;, // also all Rust int types (u32, u8, i64 etc..)
      &quot;float&quot;: &quot;{{anyFloat}}&quot;,
      &quot;anyDate&quot;: &quot;{{anyDate}}&quot; // or 'anyTime', 'anyDatetime', 'anyIso8601'
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="request"><a class="header" href="#request">Request</a></h1>
<p>With request matching you have to describe all the conditions the incoming http requests have to match in order for your
stub response to be served. Most of the time, you will opt in for a conservative approach where you will have exhaustive
and strict conditions. That's when you want to assess the http caller behaves the right way. Other times you do not care
about request matching at all e.g. you use <a href="https://github.com/beltram/stubr">stubr</a> to benchmark a reverse proxy: in that
case <code>request { &quot;method&quot;: &quot;ANY&quot; }</code> is enough. <strong>Just write the request matching you need</strong>.</p>
<h2 id="method"><a class="header" href="#method">Method</a></h2>
<p>Expects the request method. Use <code>ANY</code> when you do not care which method it will be.<br />
Available verbs are <code>GET</code>, <code>HEAD</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>CONNECT</code>, <code>OPTIONS</code>, <code>TRACE</code>, <code>PATCH</code></p>
<p><em>Note: <code>method</code> is optional and defaults to <code>ANY</code></em></p>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;method&quot;: &quot;GET&quot;
  }
}
</code></pre>
<h2 id="uri"><a class="header" href="#uri">URI</a></h2>
<p>To match request's URI (and maybe its query parameters). Only one of the following matcher is allowed. If more than one
are present, it does not fail but chooses one matcher according to the descending
priority <code>url</code> &gt; <code>urlPath</code> &gt; <code>urlPattern</code> &gt; <code>urlPathPattern</code></p>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;url&quot;: &quot;/api/uri?age=young&quot;,
    &quot;urlPath&quot;: &quot;/api/exact-uri&quot;,
    &quot;urlPattern&quot;: &quot;/api/regex-uri/([a-z]{4})\\?and=([a-z]{4})&quot;,
    &quot;urlPathPattern&quot;: &quot;/api/regex-uri/([a-z]{4})&quot;
  }
}
</code></pre>
<ul>
<li><code>url</code>: Matches by equality the URI and query parameters.</li>
<li><code>urlPath</code>: Matches by equality <strong>just</strong> the URI without query parameters.</li>
<li><code>urlPattern</code>: Matches URI and query parameters. Path segments and query parameters value can contain regexes.</li>
<li><code>urlPathPattern</code>: Matches <strong>just</strong> the URI without query parameters. Path segments can contain regexes.</li>
</ul>
<h2 id="query-parameters"><a class="header" href="#query-parameters">Query parameters</a></h2>
<p>Allows matching query parameters. Prefer this instead of <a href="stubs/request.html#uri">URI</a> matching just because it is clearer. Multivalued
query parameters are not supported yet.</p>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;queryParameters&quot;: {
      &quot;firstname&quot;: { &quot;equalTo&quot;: &quot;beltram&quot; },
      &quot;lastname&quot;: { &quot;equalTo&quot;: &quot;maldant&quot;, &quot;caseInsensitive&quot;: true },
      &quot;age&quot;: { &quot;absent&quot;: true },
      &quot;birthdate&quot;: { &quot;absent&quot;: false },
      &quot;city&quot;: { &quot;contains&quot;: &quot;at&quot; },
      &quot;title&quot;: { &quot;matches&quot;: &quot;([A-Za-z]+)&quot; },
      &quot;job&quot;: { &quot;doesNotMatch&quot;: &quot;([A-Za-z]+)&quot; }
    }
  }
}
</code></pre>
<ul>
<li><code>equalTo</code> by equality matcher. Can be a string, a boolean, a number, null etc... Can be turned case-insensitive
with <code>caseInsensitive</code>.</li>
<li><code>absent</code> specified query parameter key must be absent/present.</li>
<li><code>contains</code> value must contain the supplied string in a case-insensitive way</li>
<li><code>matches</code>/<code>doesNotMatch</code> value must match the supplied regex (or not)</li>
</ul>
<h2 id="headers"><a class="header" href="#headers">Headers</a></h2>
<p>Header matcher are <strong>exactly</strong> the same as <a href="stubs/request.html#query-parameters">query parameter matcher</a> above.</p>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;headers&quot;: {
      &quot;content-type&quot;: { &quot;equalTo&quot;: &quot;application/json&quot; }
    }
  }
}
</code></pre>
<h2 id="authorization"><a class="header" href="#authorization">Authorization</a></h2>
<p>Those matcher are exclusive to stubr and not available in Wiremock. They allow crafting more relaxed request matchers
when it comes to authorization. You could for example have stubs specialized for a specific user (we sometimes persona).</p>
<p>You can have matchers for Basic authentication (<a href="https://datatracker.ietf.org/doc/html/rfc7617">RFC 7617</a>). For example,
for matching <code>Authorization: Basic am9obi5kb2U6Y2hhbmdlbWU=</code> you would have:</p>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;basicAuth&quot;: {
      &quot;username&quot;: &quot;john.doe&quot;,
      &quot;password&quot;: &quot;changeme&quot;
    }
  }
}
</code></pre>
<p>You can also match a JWT token in the <code>Authorization</code> header as
per <a href="https://datatracker.ietf.org/doc/html/rfc7519">RFC 7519</a></p>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;jwtAuth&quot;: {
      &quot;equalTo&quot;: &quot;eyJhbGciOiJSUzI1NiJ9.e30.MBkQ...&quot;,
      &quot;alg&quot;: {
        &quot;equalTo&quot;: &quot;RS256&quot;,
        &quot;oneOf&quot;: [ &quot;RS256&quot;, &quot;HS256&quot; ]
      },
      &quot;payloadPatterns&quot;: [
        { &quot;equalToJson&quot;: { &quot;iss&quot;: &quot;john.doe&quot; } },
        { &quot;equalToJson&quot;: { &quot;exp&quot;: 1300819380 } },
        {
          &quot;expression&quot;: &quot;$.address&quot;,
          &quot;equalToJson&quot;: { &quot;street&quot;: &quot;rue de Rivoli&quot;, &quot;city&quot;: &quot;Paris&quot; }
        }
      ]
    }
  }
}
</code></pre>
<ul>
<li><code>equalTo</code> by equality matcher. Equivalent to <code>&quot;headers&quot;:{&quot;authorization&quot;:{&quot;equalTo&quot;: &quot;...&quot;}}</code>. If you have this
matcher, all the other ones will be ignored</li>
<li><code>alg.equalTo</code> by equality matcher. JWT algorithm has to be exactly this</li>
<li><code>alg.oneOf</code> JWT algorithm has to be one of the supplied values. Here are all the supported JWT
algorithms: <code>HS256</code>, <code>HS384</code>, <code>HS512</code>, <code>ES256</code>, <code>ES384</code>, <code>RS256</code>, <code>RS384</code>, <code>RS512</code>, <code>PS256</code>, <code>PS384</code>, <code>PS512</code>, <code>EdDSA</code></li>
<li><code>payloadPatterns</code> for matching the JWT body. Exactly the same matcher as <a href="stubs/request.html#body">body</a> ones.</li>
</ul>
<h2 id="body"><a class="header" href="#body">Body</a></h2>
<pre><code class="language-json">{
  &quot;request&quot;: {
    &quot;bodyPatterns&quot;: [
      { &quot;equalToJson&quot;: { &quot;name&quot;: &quot;bob&quot; } },
      {
        &quot;equalToJson&quot;: {&quot;names&quot;: [&quot;alice&quot;, &quot;bob&quot;]},
        &quot;ignoreExtraElements&quot;: true,
        &quot;ignoreArrayOrder&quot;: true
      },
      { &quot;matchesJsonPath&quot;: &quot;$.name&quot; },
      { &quot;matchesJsonPath&quot;: &quot;$.consoles[?(@.name == 'xbox')]&quot; },
      { &quot;matchesJsonPath&quot;: &quot;$.consoles[?(@.price &gt; 200)]&quot; },
      { &quot;expression&quot;: &quot;$.name&quot;, &quot;contains&quot;: &quot;at&quot; },
      { &quot;expression&quot;: &quot;$.user&quot;, &quot;equalToJson&quot;: { &quot;name&quot;: &quot;bob&quot; } },
      { &quot;expression&quot;: &quot;$.age&quot;, &quot;equalToJson&quot;: 42 },
      { &quot;binaryEqualTo&quot;: &quot;AQID&quot; }
    ]
  }
}
</code></pre>
<ul>
<li><code>equalToJson</code> strict equality matcher. Request body has to be exactly equal to this. If it is not used
with <code>expression</code>, all other matchers will be ignored. However, it can be relaxed with:
<ul>
<li><code>ignoreExtraElements</code> to ignore json fields in the http request not present in the matcher</li>
<li><code>ignoreArrayOrder</code> to match json arrays regardless the order of their items</li>
</ul>
</li>
<li><code>expression</code> a <a href="https://www.ietf.org/archive/id/draft-goessner-dispatch-jsonpath-00.html">JSONPath</a> matcher used to
narrow the matching. The matched expression has then to be verified by either:
<ul>
<li><code>equalToJson</code> for strict equality (can be another json object, a string, number etc..)</li>
<li><code>contains</code> ; if json matched by <code>expression</code> is a string it must contain the supplied string</li>
</ul>
</li>
<li><code>matchesJsonPath</code> json request body has to contain the supplied key identified by
a <a href="https://www.ietf.org/archive/id/draft-goessner-dispatch-jsonpath-00.html">JSONPath</a>. You can also
use <a href="https://docs.hevodata.com/sources/streaming/rest-api/writing-jsonpath-expressions/">JSONPath expression</a> to also
filter and match the json values</li>
<li><code>binaryEqualTo</code> byte equality matcher. Has to be base 64 encoded</li>
</ul>
<h2 id="priority"><a class="header" href="#priority">Priority</a></h2>
<p>Sometimes, you can have 2 different stubs that could both match a given http request. This happens most of the time when
you start writing stubs for your application errors. You basically should have:</p>
<ul>
<li>one relaxed stub for your nominal case matching for example <code>&quot;urlPathPattern&quot;: &quot;/users/([0-9]{4})&quot;</code></li>
<li>one stub for each error with hardcoded value e.g. <code>&quot;urlPath&quot;: &quot;/users/1234&quot;</code> for a <code>404</code> response</li>
</ul>
<p>The issue here is that if your stub server receives a <code>GET /users/1234</code> request, both stubs will match. You want your
error stub to have a higher than the nominal e.g. error stub will have a priority of 1 whereas the nominal one will have
a priority of 2.</p>
<pre><code class="language-json">{
  &quot;priority&quot;: 1
}
</code></pre>
<ul>
<li><code>priority</code> a u8. 1 is the highest priority, 255 the lowest, 5 the default value when absent. It is optional.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="response"><a class="header" href="#response">Response</a></h1>
<p>In the response part, you have to define the actual http response the stub server will serve when the stub matches the
incoming http request as we defined it with <a href="stubs/../stubs/request.html">request matching</a></p>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<p>The http response status. In the range <code>[100..599]</code>.</p>
<pre><code class="language-json">{
  &quot;response&quot;: {
    &quot;status&quot;: 200
  }
}
</code></pre>
<h2 id="header"><a class="header" href="#header">Header</a></h2>
<p>Http response headers. Note that keys are case-insensitive. Multivalued headers are not supported yet. You can
use <a href="stubs/response.html#response-templating">response templating</a> here as well if you add <code>&quot;transformers&quot;: [&quot;response-template&quot;]</code>.</p>
<pre><code class="language-json">{
  &quot;response&quot;: {
    &quot;transformers&quot;: [
      &quot;response-template&quot;
    ],
    &quot;headers&quot;: {
      &quot;content-type&quot;: &quot;application/json&quot;,
      &quot;ETag&quot;: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;,
      &quot;location&quot;: &quot;{{request.url}}/1234&quot;
    }
  }
}
</code></pre>
<h2 id="body-1"><a class="header" href="#body-1">Body</a></h2>
<p>There are different ways to define a http response. We'll just focus here on supplying hardcoded values in the response,
but you can relax all those fields with templates. We'll see that immediately in the next chapter.</p>
<pre><code class="language-json">{
  &quot;response&quot;: {
    &quot;body&quot;: &quot;Hello World !&quot;,
    &quot;base64Body&quot;: &quot;AQID&quot;,
    &quot;bodyFileName&quot;: &quot;tests/stubs/response.json&quot;,
    &quot;jsonBody&quot;: {
      &quot;name&quot;: &quot;john&quot;,
      &quot;surnames&quot;: [
        &quot;jdoe&quot;,
        &quot;johnny&quot;
      ]
    }
  }
}
</code></pre>
<ul>
<li><code>body</code> use this one if you have a text body or anything simple. If the body is large you'd better opt
for <code>bodyFileName</code>.</li>
<li><code>base64Body</code> if the body is not utf-8 encoded use it to supply a body as byte. Those have to be base 64 encoded.</li>
<li><code>bodyFileName</code> when the response gets large or to factorize some very common bodies, it is sometimes preferable to
extract it in a file. When using it in a Rust project, the file path is relative to the workspace root. You can also
use templating to dynamically select a file.</li>
<li><code>jsonBody</code> when the body is json. Even though such a body can be defined with all the previous fields, it is more
convenient to define a json response body here.</li>
</ul>
<h2 id="relaxed-field"><a class="header" href="#relaxed-field">Relaxed field</a></h2>
<p>Using only hardcoded values is a good way to start mocking things. But as time goes on, your project might start to get
bloated with a lot of stubs. You will also see the limit of hardcoded values when
doing <a href="stubs/../contract/index.html">contract testing</a>.</p>
<p>In order to &quot;relax&quot; your stub, you will have to use <a href="https://handlebarsjs.com/">Handlebars</a> helpers. They will allow you
to have random values generated for you, because, most of the time, that's what the actual application does. And, as a
consumer, you also don't care about the actual value of this field in your test i.e. <code>&quot;age&quot;: &quot;{{anyU8}}&quot;</code> will work in
all your unit tests because none of your unit tests expects a particular value for this field.</p>
<p>In order to use a Handlebars helper, you need to add <code>&quot;transformers&quot;: [&quot;response-template&quot;]</code>.</p>
<p>Keep in mind that such helper will also be used to generate assertions when you will be using this stub
for <a href="stubs/../contract/index.html">contract testing</a> while <a href="stubs/../contract/producer.html">verifying your producer</a>.</p>
<p>NB: those templates are not available in <a href="https://github.com/tomakehurst/wiremock">Wiremock</a>, you can only use them in
<a href="https://github.com/beltram/stubr">stubr</a>.</p>
<pre><code class="language-json">{
  &quot;response&quot;: {
    &quot;transformers&quot;: [
      &quot;response-template&quot;
    ],
    &quot;jsonBody&quot;: {
      &quot;regex&quot;: &quot;{{anyRegex '[a-z]{4}'}}&quot;,
      &quot;string&quot;: &quot;{{anyNonEmptyString}}&quot;,
      &quot;alphanum&quot;: &quot;{{anyAlphaNumeric}}&quot;,
      &quot;boolean&quot;: &quot;{{anyBoolean}}&quot;,
      &quot;uuid&quot;: &quot;{{anyUuid}}&quot;,
      &quot;ip&quot;: &quot;{{anyIpAddress}}&quot;,
      &quot;host&quot;: &quot;{{anyHostname}}&quot;,
      &quot;email&quot;: &quot;{{anyEmail}}&quot;,
      &quot;enum&quot;: &quot;{{anyOf 'alpha' 'beta' 'gamma'}}&quot;,
      &quot;number&quot;: &quot;{{anyNumber}}&quot;,
      &quot;integer&quot;: &quot;{{anyI32}}&quot;,
      &quot;float&quot;: &quot;{{anyFloat}}&quot;,
      &quot;anyDate&quot;: &quot;{{anyDate}}&quot;
    }
  }
}
</code></pre>
<ul>
<li><code>anyRegex</code> generates a value matching this regex. Tip: most of the time will be used for strings but if this regex
defines an integer, a float or a boolean and is used in <code>&quot;jsonBody&quot;&quot;</code> the generated value will be cast</li>
<li><code>anyNonEmptyString</code> or <code>anyNonBlankString</code> generates an arbitrary utf-8 string</li>
<li><code>anyAlphaNumeric</code> generates an arbitrary string with only alphanumeric characters</li>
<li><code>anyBoolean</code> generates either <code>true</code> or <code>false</code></li>
<li><code>anyUuid</code> generates a random UUIDv4</li>
<li><code>anyIpAddress</code> generates a random IP address e.g. <code>127.0.0.1</code></li>
<li><code>anyHostname</code> generates an arbitrary hostname e.g. <code>https://github.com</code></li>
<li><code>anyEmail</code> generates a random valid email address e.g. <code>john.doe@gmail.com</code></li>
<li><code>anyOf</code> given the supplied values, will pick one randomly. Only works for strings.</li>
<li><code>anyNumber</code> when one does not care about the number size, generates either an integer or a float</li>
<li><code>anyI32</code> or <code>anyU32</code> etc.. generates a random integer. Possible values
are: <code>anyU64</code>, <code>anyI64</code>, <code>anyU32</code>, <code>anyI32</code>, <code>anyU16</code>, <code>anyI16</code>, <code>anyU8</code>, <code>anyI8</code></li>
<li><code>anyFloat</code> generates a random float</li>
<li><code>anyDate</code> generates a date with format <code>yyyy-mm-dd</code></li>
<li><code>anyTime</code> generates a time with format <code>hh:mm:ss</code></li>
<li><code>anyDatetime</code> generates a datetime with format <code>yyyy-mm-ddThh:mm:ss</code></li>
<li><code>anyIso8601</code> generates an <a href="https://en.wikipedia.org/wiki/ISO_8601">iso-8601</a> compliant datetime</li>
</ul>
<h2 id="response-templating"><a class="header" href="#response-templating">Response templating</a></h2>
<p>Another kind of relaxing you can do is by being able to represent as best as possible the actual http response of your
app. Very often, a field in the response is the exact same as the one in the request e.g. in a POST request to create
a REST resource. You can use in your response parts of the request to do so.</p>
<pre><code class="language-json">{
  &quot;response&quot;: {
    &quot;transformers&quot;: [
      &quot;response-template&quot;
    ],
    &quot;jsonBody&quot;: {
      &quot;url-path-and-query&quot;: &quot;{{request.url}}&quot;,
      &quot;url-path&quot;: &quot;{{request.path}}&quot;,
      &quot;url-path-segments&quot;: &quot;{{request.pathSegments.[1]}}&quot;,
      &quot;query&quot;: &quot;{{request.query.kind}}&quot;,
      &quot;multi-query&quot;: &quot;{{request.query.kind.[1]}}&quot;,
      &quot;method&quot;: &quot;{{request.method}}&quot;,
      &quot;header&quot;: &quot;{{request.headers.Content-Type}}&quot;,
      &quot;multi-header&quot;: &quot;{{request.headers.cache-control.[0]}}&quot;,
      &quot;body&quot;: &quot;{{request.body}}&quot;,
      &quot;from-request&quot;: &quot;{{jsonPath request.body '$.name'}}&quot;
    }
  }
}
</code></pre>
<ul>
<li><code>request.url</code> given a request to <code>http://localhost/api/path?a=b</code> returns <code>path?a=b</code></li>
<li><code>request.path</code> given a request to <code>http://localhost/api/path?a=b</code> returns <code>api/path</code></li>
<li><code>request.pathSegments.[i]</code> allows picking a part of the url path (<code>i</code> is zero indexed) e.g.
<code>http://localhost/a/b/c</code> with <code>i</code> == 1 returns <code>b</code></li>
<li><code>query.&lt;selector&gt;.[i]</code> allows picking a named query parameter. Replace <code>&lt;selector&gt;</code> by the name of the query
parameter. If the query parameter is multivalued, you can select only one with the zero indexed <code>i</code>. For example with
<code>http://localhost?a=1&amp;a=2&amp;a=3&amp;b=1</code> then <code>{{query.b}}</code> returns <code>1</code> and <code>{{query.a.[1]}}</code> returns <code>2</code></li>
<li><code>request.method</code> returns the (uppercase) http request method. If you want the lowercase method
just <code>{{lower request.method}}</code></li>
<li><code>request.headers.&lt;selector&gt;.[i]</code> about the same as picking query parameters. Note that here <code>selector</code> is
case-insensitive.</li>
<li><code>request.body</code> takes the raw request body without altering it</li>
<li><code>jsonPath request.body '&lt;json-path&gt;'</code> for templating only a field from request's json body. <code>json-path</code> is the
JSONPath
for selecting the right field. Use an <a href="https://jsonpath.com/">online JSONPath evaluator</a> to try out your paths.</li>
</ul>
<p>You also sometimes have to generate dynamic data or to transform existing one:</p>
<pre><code class="language-json">{
  &quot;response&quot;: {
    &quot;transformers&quot;: [
      &quot;response-template&quot;
    ],
    &quot;jsonBody&quot;: {
      &quot;now&quot;: &quot;{{now}}&quot;,
      &quot;now-fmt&quot;: &quot;{{now format='yyyy/MM/dd'}}&quot;,
      &quot;now-fmt-epoch&quot;: &quot;{{now format='epoch'}}&quot;,
      &quot;now-fmt-unix&quot;: &quot;{{now format='unix'}}&quot;,
      &quot;now-positive-offset&quot;: &quot;{{now offset='3 days'}}&quot;,
      &quot;now-negative-offset&quot;: &quot;{{now offset='-3 days'}}&quot;,
      &quot;now-with-timezone&quot;: &quot;{{now timezone='Europe/Rome'}}&quot;,
      &quot;number-is-odd&quot;: &quot;{{isOdd request.body}}&quot;,
      &quot;number-stripes&quot;: &quot;{{stripes request.body 'if-even' 'if-odd'}}&quot;,
      &quot;string-capitalized&quot;: &quot;{{capitalize request.body}}&quot;,
      &quot;string-uppercase&quot;: &quot;{{upper request.body}}&quot;,
      &quot;string-trim&quot;: &quot;{{trim request.body}}&quot;,
      &quot;size&quot;: &quot;{{size request.body}}&quot;,
      &quot;base64-encode&quot;: &quot;{{base64 request.body padding=false}}&quot;,
      &quot;base64-decode&quot;: &quot;{{base64 request.body decode=true}}&quot;,
      &quot;url-encode&quot;: &quot;{{urlEncode request.header.x-raw}}&quot;,
      &quot;url-decode&quot;: &quot;{{urlEncode request.header.x-encoded decode=true}}&quot;
    }
  }
}
</code></pre>
<ul>
<li><code>now</code> by default return the current datetime in <a href="https://www.rfc-editor.org/rfc/rfc3339">RFC 3339</a> format (this is
only for backward compatibility with Wiremock)
<ul>
<li><code>format</code> could be either:
<ul>
<li>a custom <a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html">Java SimpleDateFormat</a> (
for Wiremock compatibility) e.g. <code>format='yyyy/MM/dd'</code></li>
<li><code>epoch</code> Unix timestamp in milliseconds</li>
<li><code>unix</code> Unix timestamp in seconds</li>
</ul>
</li>
<li><code>offset</code> now with the given offset expressed in human-readable format. Refer
to <a href="https://docs.rs/humantime/latest/humantime/fn.parse_duration.html">humantime documentation</a> for further
examples.</li>
<li><code>timezone</code> for using a string timezone (
see <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List">list</a>)</li>
</ul>
</li>
<li><code>isOdd</code> or <code>isEven</code> returns a boolean whether the numeric value is an even or odd integer</li>
<li><code>capitalize</code> first letter to uppercase e.g. <code>mister</code> becomes <code>Mister</code></li>
<li><code>upper</code> or <code>lower</code> recapitalizes the whole word</li>
<li><code>stripes</code> returns alternate values depending if the tested value is even or odd</li>
<li><code>trim</code> removes leading &amp; trailing whitespaces</li>
<li><code>size</code> returns the number of bytes for a string (âš ï¸ not the number of characters) or the size of an array</li>
<li><code>base64</code> for standard (no base64 url encoding yet) Base64 encoding
<ul>
<li><code>decode</code> for decoding when true</li>
<li><code>padding</code> with/without padding</li>
</ul>
</li>
<li><code>urlEncode</code> for url encoding the value. Use <code>decode=true</code> to decode</li>
</ul>
<h2 id="simulate-fault"><a class="header" href="#simulate-fault">Simulate fault</a></h2>
<p>You can also use <a href="https://github.com/beltram/stubr">stubr</a> to simulate http server runtime behaviour. And most of the
time you'll want to introduce
latencies
to check how your consuming application reacts to such delays. Currently, the options are quite sparse but should grow !</p>
<pre><code class="language-json">{
  &quot;expect&quot;: 2,
  &quot;response&quot;: {
    &quot;fixedDelayMilliseconds&quot;: 2000
  },
  &quot;delayDistribution&quot;: {
    // a random delay with logarithmic distribution
    &quot;type&quot;: &quot;lognormal&quot;,
    &quot;median&quot;: 100,
    // The 50th percentile of latencies in milliseconds
    &quot;sigma&quot;: 0.1
    // Standard deviation. The larger the value, the longer the tail
  }
}
</code></pre>
<ul>
<li><code>expect</code> will allow to verify that your unit test has not called the given stub more than N times. Turn it on like
this <code>stubr::Stubr::start_with(stubr::Config { verify: true, ..Default::default() })</code>
or <code>#[stubr::mock(verify = true)]</code> with the attribute macro</li>
<li><code>fixedDelayMilliseconds</code> a delay (in milliseconds) added everytime this stub is matched. If you are
using <a href="https://github.com/beltram/stubr">stubr</a>
standalone through the <a href="stubs/../cli.html">cli</a>, this value can be either superseded by <code>--delay</code> or complemented
by <code>--latency</code></li>
<li><code>delayDistribution</code> for random delays (always in milliseconds), use <code>type</code> to choose the one
<ul>
<li><code>lognormal</code> is a pretty good approximation of long tailed latencies centered on the 50th
percentile. <a href="https://www.wolframalpha.com/input/?i=lognormaldistribution%28log%2890%29%2C+0.4%29">Try different values</a>
to find a good approximation.
<ul>
<li><code>median</code>: the 50th percentile of latencies in milliseconds</li>
<li><code>sigma</code>: standard deviation. The larger the value, the longer the tail.</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording-1"><a class="header" href="#recording-1">Recording</a></h1>
<p>Writing stubs by hand can be... well, painful. More often than not, you already have an existing app ready and you just
want to mock it for consumers. Or you are from those who prefer writing code before tests. Or you are lazy ðŸ˜….</p>
<p>All those are valid reasons and in order to help you with that, you can record real http traffic and turn it into json
stub files. If you are not at all working on Rust projects, you can <a href="recording/cli.html">record using the cli</a> to capture traffic
from for example a real application in production written in Java. If you are in a Rust project and use a http client
library, you can record its traffic in tests for <a href="recording/actix.html">actix</a>, <a href="recording/isahc.html">isahc</a> or <a href="recording/reqwest.html">reqwest</a>. And
if your favorite http client is not is this list you can still record using a <a href="recording/standalone.html">standalone</a> recorder. 
Recording in a Rust consumer is mostly about getting faster, especially with &quot;fat&quot; endpoints with hundreds of fields. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording-your-actix-app"><a class="header" href="#recording-your-actix-app">Recording your actix app</a></h1>
<p>You can plug recording in your existing <a href="https://actix.rs/docs/testing/#integration-tests">actix integration tests</a> by 
just adding a single line: <code>.wrap(stubr::ActixRecord::default())</code>. This will register a middleware which will capture
the http request and response, then dump them under <code>./target/stubs/localhost</code>.</p>
<p><em>This requires the <code>record-actix</code> feature.</em></p>
<pre><code class="language-rust ignore noplayground edition2021">use actix_web::test::{call_service, init_service, TestRequest};
use asserhttp::*;

#[actix_web::test]
async fn record_actix() {
    let app = actix_web::App::new()
        .route(&quot;/&quot;, actix_web::web::get().to(|| async { actix_web::HttpResponse::Ok().await }))
        // just add this ðŸ‘‡
        .wrap(stubr::ActixRecord::default()); // or `ActixRecord(RecordConfig)` for configuring it
    let req = TestRequest::get().uri(&quot;/&quot;).to_request();
    let svc = init_service(app).await;
    call_service(&amp;svc, req).await.expect_status_ok();
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording-with-the-cli"><a class="header" href="#recording-with-the-cli">Recording with the cli</a></h1>
<p>In order to record http traffic, <a href="https://github.com/beltram/stubr">stubr</a> can act as a proxy to dump this traffic into json stubs on your local
filesystem. Recording can be started with the <code>stubr record</code> command. Stubs will be grouped by hosts. You can then play
them back using <a href="https://github.com/beltram/stubr">stubr</a>.</p>
<div class="table-wrapper"><table><thead><tr><th>arg</th><th style="text-align: center">about</th><th style="text-align: center">examples</th></tr></thead><tbody>
<tr><td><code>--port</code></td><td style="text-align: center">Proxy port. Defaults to 3030.</td><td style="text-align: center"><code>stubr --port 3031</code> or <code>stubr -p 3031</code></td></tr>
<tr><td><code>--output</code></td><td style="text-align: center">File path where recorded stubs are stored. Default to current directory.</td><td style="text-align: center"><code>stubr --port record-1</code> or <code>stubr -o record-1</code></td></tr>
</tbody></table>
</div>
<h3 id="example"><a class="header" href="#example">example</a></h3>
<p>First, start <a href="https://github.com/beltram/stubr">stubr</a> recorder on port <code>3030</code>. It will act as a proxy.</p>
<pre><code class="language-bash">stubr record -p 3030
</code></pre>
<p>We are going to consume a publicly available endpoint returning a list of sample users. We'll use <a href="https://curl.se/">curl</a>
to make this http call, and we will configure it to use our recorder as a proxy.</p>
<pre><code class="language-bash">curl jsonplaceholder.typicode.com/users --proxy http://localhost:3030
</code></pre>
<p>You should have a stub under <code>jsonplaceholder.typicode.com/users-*.json</code> following the pattern <code>{domain}/{path}-{md5-hash}.json</code>.</p>
<p>NB: <em>That way of recording is less intrusive than <a href="https://wiremock.org/docs/record-playback/">if you had to do it with wiremock,</a>
and you can configure. Most of the tools e.g. <a href="https://curl.se/">curl</a>, <a href="https://jmeter.apache.org/">JMeter</a>, <a href="https://k6.io/">k6</a> or
simply your web browser support configuring a http proxy (and more often than not, just by setting an environment variable,
leaving your tests/scripts untouched).</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording-your-isahc-calls"><a class="header" href="#recording-your-isahc-calls">Recording your isahc calls</a></h1>
<p>The only way currently to record isahc is to spawn a proxy and configure isahc to use this proxy. This is exactly what
the following snippet does.</p>
<p><em>This requires the <code>record-isahc</code> feature.</em></p>
<pre><code class="language-rust ignore noplayground edition2021">use asserhttp::*;

#[tokio::test(flavor = &quot;multi_thread&quot;)] // ðŸ‘ˆ required by recording proxy
#[stubr::mock(&quot;ping.json&quot;)] // ðŸ‘ˆ spawn a mock server
async fn record_isahc() {
    // ðŸ‘‡ spawn the recording proxy
    stubr::Stubr::record() // or `record_with()` for configuring it
        // ðŸ‘‡ builds an isahc client with proxy configured
        .isahc_client()
        .get(stubr.uri())
        .expect_status_ok();
}</code></pre>
<p>You can find your recorded stubs under <code>./target/stubs/localhost</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording-your-reqwest-calls"><a class="header" href="#recording-your-reqwest-calls">Recording your reqwest calls</a></h1>
<p>You have 2 ways to record reqwest http calls ; either with the <code>stubr::Record</code> trait (highly recommended) or the &quot;original&quot;
way, still supported, with a standalone recording proxy.</p>
<p><em>This requires the <code>record-reqwest</code> feature.</em></p>
<h2 id="trait-recommended"><a class="header" href="#trait-recommended">trait (recommended)</a></h2>
<pre><code class="language-rust ignore noplayground edition2021">use asserhttp::*;
use stubr::Record as _;

#[test]
#[stubr::mock(&quot;ping.json&quot;)] // ðŸ‘ˆ spawn a mock server
fn record_reqwest_trait() {
    // recording unfortunately requires using reqwest's builder hence the syntax is a bit verbose
    let req = reqwest::blocking::ClientBuilder::new().build().unwrap()
        .get(stubr.uri())
        // ðŸ‘‡ this will intercept and dump all http traffic going through this client
        .record() // or `record_with()` for configuring it
        .build().unwrap();
    reqwest::blocking::Client::default().execute(req).unwrap().expect_status_ok();
}</code></pre>
<p>You can find your recorded stubs under <code>./target/stubs/localhost</code></p>
<p><em>NB: async is not supported yet</em></p>
<h2 id="standalone"><a class="header" href="#standalone">standalone</a></h2>
<pre><code class="language-rust ignore noplayground edition2021">use asserhttp::*;

#[tokio::test(flavor = &quot;multi_thread&quot;)] // ðŸ‘ˆ required by recording proxy
#[stubr::mock(&quot;ping.json&quot;)] // ðŸ‘ˆ spawn a mock server
async fn record_reqwest() {
    // ðŸ‘‡ spawn the recording proxy
    stubr::Stubr::record() // or `record_with()` for configuring it
        // ðŸ‘‡ builds a reqwest client with proxy configured
        .reqwest_client()
        .get(stubr.uri())
        .send()
        .await
        .expect_status_ok();
}</code></pre>
<p>You can find your recorded stubs under <code>./target/stubs/localhost</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recording-standalone"><a class="header" href="#recording-standalone">Recording standalone</a></h1>
<p>If you don't fall into one of the previous boxes (for example if you use another http client), you can still record the http
traffic by using the standalone recording proxy, the exact same one used in the <a href="recording/../cli.html">cli</a>.</p>
<p>To do so, you just have to spawn the proxy and then configure your http client to use this proxy.</p>
<p><em>This requires the <code>record</code> feature.</em></p>
<pre><code class="language-rust ignore noplayground edition2021">#[tokio::test(flavor = &quot;multi_thread&quot;)]
async fn record_standalone() {
    // ðŸ‘‡ spawn the recording proxy
    let proxy = stubr::Stubr::record();
    // or use `record_with()` for configuring it
    let _proxy_uri = proxy.uri();
    // â˜ï¸ then use this uri to configure your http client
}</code></pre>
<p>Or, in order to keep the syntax short, you can use the provided attribute macro.</p>
<pre><code class="language-rust ignore noplayground edition2021">// works for async as well
#[stubr::record] // ðŸ‘ˆ this spawns the proxy and creates a 'recorder' binding in the function
// #[stubr::record(port = 1234)] for setting a port
#[test]
fn record_standalone() {
    let _proxy_uri = recorder.uri();
    // â˜ï¸ then use this uri to configure your http client
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grpc"><a class="header" href="#grpc">gRPC</a></h1>
<p>Stubr also supports mocking a gRPC service ! To do so, it
leverages <a href="https://protobuf.dev/programming-guides/proto3/#json">Protobuf to json mapping</a> in order to ; first to reuse
all the request matchers and response templates already available and implemented ; then, to let you instantiate (give a
value to the fields) your messages using json (you can't assign a value to a field in Protobuf).</p>
<p>The API looks like this:</p>
<pre><code class="language-json">{
  &quot;protoFile&quot;: &quot;path/to/grpc.proto&quot;, // protobuf file where gRPC service &amp; protobuf messages are defined
  &quot;grpcRequest&quot;: {
    &quot;message&quot;: &quot;Pet&quot;, // name of the body's message in 'protoFile' 
    &quot;service&quot;: &quot;PetStore&quot;, // (optional) name of the gRPC service to mock, supports Regex
    &quot;method&quot;: &quot;createDog&quot;, // (optional) name of the gRPC method to mock, supports Regex
    &quot;bodyPatterns&quot;: [
      {
        &quot;equalToJson&quot;: { // literally the same matchers as in http
          &quot;name&quot;: &quot;Rex&quot;,
          &quot;race&quot;: &quot;dog&quot;
        }
      }
    ]
  },
  &quot;grpcResponse&quot;: {
    &quot;status&quot;: &quot;OK&quot;, // or &quot;CANCELLED&quot;, &quot;NOT_FOUND&quot; etc..
    &quot;message&quot;: &quot;Pet&quot;, // name of the body's message in 'protoFile'
    &quot;body&quot;: { // literally the same as in http, supports templating too
      &quot;id&quot;: 1234,
      &quot;name&quot;: &quot;{{jsonPath request.body '$.name'}}&quot;,
      &quot;race&quot;: &quot;{{jsonPath request.body '$.race'}}&quot;,
      &quot;action&quot;: &quot;{{request.method}}&quot;, // only 2 differences with standard templates
      &quot;service&quot;: &quot;{{request.service}}&quot;
    },
    &quot;transformers&quot;: [ // required for response templating
      &quot;response-template&quot;
    ]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli"><a class="header" href="#cli">Cli</a></h1>
<p>You can use <a href="https://github.com/beltram/stubr">stubr</a> as a cli for serving Wiremock stubs on a local server or as proxy for recording http traffic into
json stubs.</p>
<p>To get a list of all available options run <code>stubr --help</code></p>
<div class="table-wrapper"><table><thead><tr><th>arg</th><th style="text-align: center">about</th><th style="text-align: center">examples</th></tr></thead><tbody>
<tr><td><code>[dir]</code></td><td style="text-align: center">Folder containing stubs or individual stub.</td><td style="text-align: center"><code>stubr ./my-app-stubs</code> or <code>stubr ./my-app-stubs/ping.json</code></td></tr>
<tr><td><code>--root-dir</code></td><td style="text-align: center">Directory containing a <code>mappings</code> folder with all stubs. Equivalent to Wiremock's one. Has precedence over <code>[dir]</code></td><td style="text-align: center"><code>stubr --root-dir ./my-app-stubs</code></td></tr>
<tr><td><code>--port</code></td><td style="text-align: center">Server port. Defaults to random port.</td><td style="text-align: center"><code>stubr --port 8080</code> or <code>stubr -p 8080</code></td></tr>
<tr><td><code>--delay</code></td><td style="text-align: center">Global delay duration applied to all stubs (supersedes any locally defined delay).</td><td style="text-align: center"><code>stubr --delay 2s</code> or <code>stubr -d 1m</code> or <code>stubr -d 100ms</code></td></tr>
<tr><td><code>--latency</code></td><td style="text-align: center">Delay added to any locally defined delay. Simulates network latency.</td><td style="text-align: center"><code>stubr --latency 2s</code> or <code>stubr -l 1m</code> or <code>stubr -l 100ms</code></td></tr>
<tr><td><code>completion</code></td><td style="text-align: center">Generates &amp; installs bash or zsh completion scripts</td><td style="text-align: center"><code>stubr completion bash</code> or <code>stubr completion zsh</code></td></tr>
<tr><td><code>--help</code></td><td style="text-align: center">Displays help.</td><td style="text-align: center"><code>stubr help</code> or <code>stubr -h</code> for short help. <code>stubr --help</code> for long help</td></tr>
<tr><td><code>--version</code></td><td style="text-align: center">Displays <code>stubr</code> version.</td><td style="text-align: center"><code>stubr -V</code> or <code>stubr --version</code></td></tr>
</tbody></table>
</div>
<h2 id="install-it"><a class="header" href="#install-it">install it</a></h2>
<h3 id="precompiled-binaries"><a class="header" href="#precompiled-binaries">precompiled binaries</a></h3>
<p>If you don't want to install <a href="https://rustup.rs/">Rust toolchain</a>, you can always download precompiled binaries. They
have the advantage of being optimized with <a href="https://upx.github.io/">upx</a> hence they are just smaller than the ones you'd
get from sources.</p>
<h4 id="linux-1"><a class="header" href="#linux-1">linux:</a></h4>
<pre><code class="language-bash">curl -L https://github.com/beltram/stubr/releases/latest/download/stubr-linux.tar.gz | tar xz - -C /usr/local/bin
</code></pre>
<h4 id="macos-1"><a class="header" href="#macos-1">macos:</a></h4>
<pre><code class="language-bash">curl -L https://github.com/beltram/stubr/releases/latest/download/stubr-macos.tar.gz | tar xz - -C /usr/local/bin
</code></pre>
<h3 id="from-source"><a class="header" href="#from-source">from source</a></h3>
<pre><code class="language-bash">cargo install stubr-cli
</code></pre>
<h3 id="once-installed-generate-completion"><a class="header" href="#once-installed-generate-completion">once installed, generate completion</a></h3>
<p>Completion files generation is currently supported for <code>bash</code> and <code>zsh</code>. <a href="https://github.com/beltram/stubr">Stubr</a> cli
provides a <code>completion</code> command to generate and install them in a standard location.</p>
<pre><code class="language-bash">stubr completion zsh
# or
stubr completion bash
</code></pre>
<h2 id="getting-started-3"><a class="header" href="#getting-started-3">getting started</a></h2>
<p>The simplest usage is for serving Wiremock stubs under a directory (or just a single file).<br />
For example let's generate a simple stub file.</p>
<pre><code class="language-bash">echo &quot;{\&quot;request\&quot;: {\&quot;method\&quot;: \&quot;GET\&quot;}, \&quot;response\&quot;: { \&quot;status\&quot;: 200 }}&quot; &gt; hello.json
</code></pre>
<p>Then simply run it with the following command.</p>
<pre><code class="language-bash">stubr hello.json
</code></pre>
<p>Which will generate something like that.</p>
<pre><code class="language-bash"> &gt; + mounted &quot;hello.json&quot;
 &gt; Started stubr in 50ms on http://127.0.0.1:49604
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker"><a class="header" href="#docker">Docker</a></h1>
<p>A docker image is published <a href="https://github.com/users/beltram/packages/container/package/stubr">here</a> with each release.</p>
<p>You can play with it with the following commands:</p>
<pre><code class="language-bash">echo &quot;{\&quot;request\&quot;: {\&quot;method\&quot;: \&quot;GET\&quot;}, \&quot;response\&quot;: { \&quot;body\&quot;: \&quot;Hello stubr\&quot; }}&quot; &gt; hello.json &amp;&amp;
docker run -v $(pwd):/stubs -d --rm -p 8080:8080 ghcr.io/beltram/stubr:latest /stubs -p 8080 &amp;&amp;
http :8080
</code></pre>
<p>Which should output</p>
<pre><code class="language-bash">HTTP/1.1 200 OK
content-length: 11
content-type: text/plain
date: Tue, 23 Mar 2021 13:37:41 GMT
server: stubr(0.6.1)

Hello stubr
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benchmark"><a class="header" href="#benchmark">Benchmark</a></h1>
<h2 id="vs-wiremock"><a class="header" href="#vs-wiremock">vs wiremock</a></h2>
<p>A very simple benchmark comparing <a href="https://github.com/beltram/stubr">stubr</a> to wiremock is
available <a href="https://github.com/beltram/stubr/blob/main/bench/README.md">here</a></p>
<h2 id="standalone-1"><a class="header" href="#standalone-1">standalone</a></h2>
<p>A benchmark of <a href="https://github.com/beltram/stubr">stubr</a> itself, powered
by <a href="https://crates.io/crates/criterion">criterion</a> is available for each release. The latest is
available <a href="https://github.com/beltram/stubr/releases/latest/download/bench.tar.gz">here</a>. It aims at tracking down
progresses/regressions made.</p>
<p>I'm still looking for a way to turn this into something more ergonomic, especially I'd like to provide a way to compare
2 benchmarks. Meanwhile, you can download the latest benchmark with these commands.</p>
<pre><code class="language-bash">mkdir stubr-bench &amp;&amp;
curl -L https://github.com/beltram/stubr/releases/latest/download/bench.tar.gz | tar xz - -C stubr-bench
</code></pre>
<p>Then open <code>./stubr-bench/report/index.html</code> in your browser.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ide-completion"><a class="header" href="#ide-completion">IDE completion</a></h1>
<p>A json schema is also maintained <a href="https://github.com/beltram/stubr/blob/main/schemas/stubr.schema.json">here</a> to provide
completion in IDE. It just contains completion for features implemented in <a href="https://github.com/beltram/stubr">stubr</a> and should alleviate you from a bit of
pain when writing json from scratch.</p>
<details>
<summary><b>IntelliJ</b></summary>
<ul>
<li>Go to <code>Settings &gt; Languages &amp; Frameworks &gt; Schemas &amp; DTDs &gt; JSON Schema Mappings</code></li>
<li>Add a mapping (click on the upper <code>+</code>)</li>
<li>Then supply the following
<ul>
<li>name: <code>stubr</code></li>
<li>Schema file or URL: <code>https://raw.githubusercontent.com/beltram/stubr/main/schemas/stubr.schema.json</code></li>
<li>Schema version: <code>JSON Schema version 7</code></li>
<li>File path pattern: <code>stubs/*.json</code> (and <code>mappings/*.json</code> if you want to use it for original wiremock stubs)</li>
</ul>
</li>
<li>Then <code>Apply</code></li>
</ul>
</details>
<details>
<summary><b>VsCode</b></summary>
<ul>
<li>Open workspace settings (File &gt; Preferences &gt; Settings)</li>
<li>Add the following under the property <code>json.schemas</code></li>
</ul>
<pre><code class="language-json">&quot;json.schemas&quot;: [{&quot;fileMatch&quot;: [&quot;stubs/*.json&quot;, &quot;mappings/*.json&quot;], &quot;url&quot;: &quot;https://raw.githubusercontent.com/beltram/stubr/main/schemas/stubr.schema.json&quot;}]
</code></pre>
</details>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
